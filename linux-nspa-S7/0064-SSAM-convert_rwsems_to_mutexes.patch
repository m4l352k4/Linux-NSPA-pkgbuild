 - Remove / Replace ALL read-write semaphore code with Mutexes
 - While mutexes may not be as fast as rwsems, this seems to work better 
   on PREEMPT_RT.
 
diff -Npur a/drivers/platform/surface/aggregator/controller.c b/drivers/platform/surface/aggregator/controller.c
--- a/drivers/platform/surface/aggregator/controller.c	2023-01-02 13:25:15.383099882 -0500
+++ b/drivers/platform/surface/aggregator/controller.c	2023-01-02 13:23:48.388732595 -0500
@@ -17,7 +17,6 @@
 #include <linux/mutex.h>
 #include <linux/rculist.h>
 #include <linux/rbtree.h>
-#include <linux/rwsem.h>
 #include <linux/serdev.h>
 #include <linux/slab.h>
 #include <linux/spinlock.h>
@@ -939,7 +938,7 @@ EXPORT_SYMBOL_GPL(ssam_controller_put);
  */
 void ssam_controller_statelock(struct ssam_controller *c)
 {
-	down_read(&c->lock);
+	mutex_lock(&c->lock);
 }
 EXPORT_SYMBOL_GPL(ssam_controller_statelock);
 
@@ -951,7 +950,7 @@ EXPORT_SYMBOL_GPL(ssam_controller_statel
  */
 void ssam_controller_stateunlock(struct ssam_controller *c)
 {
-	up_read(&c->lock);
+	mutex_unlock(&c->lock);
 }
 EXPORT_SYMBOL_GPL(ssam_controller_stateunlock);
 
@@ -967,7 +966,7 @@ EXPORT_SYMBOL_GPL(ssam_controller_stateu
  */
 void ssam_controller_lock(struct ssam_controller *c)
 {
-	down_write(&c->lock);
+	mutex_lock(&c->lock);
 }
 
 /*
@@ -978,7 +977,7 @@ void ssam_controller_lock(struct ssam_co
  */
 void ssam_controller_unlock(struct ssam_controller *c)
 {
-	up_write(&c->lock);
+	mutex_unlock(&c->lock);
 }
 
 static void ssam_handle_event(struct ssh_rtl *rtl,
@@ -1168,7 +1167,7 @@ int ssam_controller_init(struct ssam_con
 	acpi_handle handle = ACPI_HANDLE(&serdev->dev);
 	int status;
 
-	init_rwsem(&ctrl->lock);
+	mutex_init(&ctrl->lock);
 	kref_init(&ctrl->kref);
 
 	status = ssam_controller_caps_load_from_acpi(handle, &ctrl->caps);
diff -Npur a/drivers/platform/surface/aggregator/controller.h b/drivers/platform/surface/aggregator/controller.h
--- a/drivers/platform/surface/aggregator/controller.h	2022-10-04 09:58:44.000000000 -0500
+++ b/drivers/platform/surface/aggregator/controller.h	2023-01-02 13:23:51.884747259 -0500
@@ -12,7 +12,6 @@
 #include <linux/list.h>
 #include <linux/mutex.h>
 #include <linux/rbtree.h>
-#include <linux/rwsem.h>
 #include <linux/serdev.h>
 #include <linux/spinlock.h>
 #include <linux/srcu.h>
@@ -198,7 +197,7 @@ struct ssam_controller_caps {
 struct ssam_controller {
 	struct kref kref;
 
-	struct rw_semaphore lock;
+	struct mutex lock;
 	enum ssam_controller_state state;
 
 	struct ssh_rtl rtl;
diff -Npur a/drivers/platform/surface/surface_acpi_notify.c b/drivers/platform/surface/surface_acpi_notify.c
--- a/drivers/platform/surface/surface_acpi_notify.c	2022-10-04 09:58:44.000000000 -0500
+++ b/drivers/platform/surface/surface_acpi_notify.c	2023-01-02 12:11:57.462385804 -0500
@@ -19,7 +19,7 @@
 #include <linux/module.h>
 #include <linux/notifier.h>
 #include <linux/platform_device.h>
-#include <linux/rwsem.h>
+#include <linux/mutex.h>
 
 #include <linux/surface_aggregator/controller.h>
 #include <linux/surface_acpi_notify.h>
@@ -42,13 +42,13 @@ static struct workqueue_struct *san_wq;
 /* -- dGPU notifier interface. ---------------------------------------------- */
 
 struct san_rqsg_if {
-	struct rw_semaphore lock;
+	struct mutex lock;
 	struct device *dev;
 	struct blocking_notifier_head nh;
 };
 
 static struct san_rqsg_if san_rqsg_if = {
-	.lock = __RWSEM_INITIALIZER(san_rqsg_if.lock),
+	.lock = __MUTEX_INITIALIZER(san_rqsg_if.lock),
 	.dev = NULL,
 	.nh = BLOCKING_NOTIFIER_INIT(san_rqsg_if.nh),
 };
@@ -57,12 +57,12 @@ static int san_set_rqsg_interface_device
 {
 	int status = 0;
 
-	down_write(&san_rqsg_if.lock);
+	mutex_lock(&san_rqsg_if.lock);
 	if (!san_rqsg_if.dev && dev)
 		san_rqsg_if.dev = dev;
 	else
 		status = -EBUSY;
-	up_write(&san_rqsg_if.lock);
+	mutex_unlock(&san_rqsg_if.lock);
 
 	return status;
 }
@@ -88,25 +88,25 @@ int san_client_link(struct device *clien
 	const u32 flags = DL_FLAG_PM_RUNTIME | DL_FLAG_AUTOREMOVE_CONSUMER;
 	struct device_link *link;
 
-	down_read(&san_rqsg_if.lock);
+	mutex_lock(&san_rqsg_if.lock);
 
 	if (!san_rqsg_if.dev) {
-		up_read(&san_rqsg_if.lock);
+		mutex_unlock(&san_rqsg_if.lock);
 		return -ENXIO;
 	}
 
 	link = device_link_add(client, san_rqsg_if.dev, flags);
 	if (!link) {
-		up_read(&san_rqsg_if.lock);
+		mutex_unlock(&san_rqsg_if.lock);
 		return -ENOMEM;
 	}
 
 	if (READ_ONCE(link->status) == DL_STATE_SUPPLIER_UNBIND) {
-		up_read(&san_rqsg_if.lock);
+		mutex_unlock(&san_rqsg_if.lock);
 		return -ENXIO;
 	}
 
-	up_read(&san_rqsg_if.lock);
+	mutex_unlock(&san_rqsg_if.lock);
 	return 0;
 }
 EXPORT_SYMBOL_GPL(san_client_link);
diff -Npur a/drivers/platform/surface/surface_aggregator_cdev.c b/drivers/platform/surface/surface_aggregator_cdev.c
--- a/drivers/platform/surface/surface_aggregator_cdev.c	2022-10-04 09:58:44.000000000 -0500
+++ b/drivers/platform/surface/surface_aggregator_cdev.c	2023-01-02 13:21:52.299251646 -0500
@@ -15,7 +15,6 @@
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/poll.h>
-#include <linux/rwsem.h>
 #include <linux/slab.h>
 #include <linux/uaccess.h>
 #include <linux/vmalloc.h>
@@ -35,14 +34,14 @@ enum ssam_cdev_device_state {
 
 struct ssam_cdev {
 	struct kref kref;
-	struct rw_semaphore lock;
+	struct mutex lock;
 
 	struct device *dev;
 	struct ssam_controller *ctrl;
 	struct miscdevice mdev;
 	unsigned long flags;
 
-	struct rw_semaphore client_lock;  /* Guards client list. */
+	struct mutex client_lock;  /* Guards client list. */
 	struct list_head client_list;
 };
 
@@ -217,7 +216,7 @@ static void ssam_cdev_notifier_unregiste
 {
 	int i;
 
-	down_read(&client->cdev->lock);
+	mutex_lock(&client->cdev->lock);
 
 	/*
 	 * This function may be used during shutdown, thus we need to test for
@@ -246,7 +245,7 @@ static void ssam_cdev_notifier_unregiste
 		WARN_ON(count > 0);
 	}
 
-	up_read(&client->cdev->lock);
+	mutex_unlock(&client->cdev->lock);
 }
 
 
@@ -481,10 +480,10 @@ static int ssam_cdev_device_open(struct
 	filp->private_data = client;
 
 	/* Attach client. */
-	down_write(&cdev->client_lock);
+	mutex_lock(&cdev->client_lock);
 
 	if (test_bit(SSAM_CDEV_DEVICE_SHUTDOWN_BIT, &cdev->flags)) {
-		up_write(&cdev->client_lock);
+		mutex_unlock(&cdev->client_lock);
 		mutex_destroy(&client->write_lock);
 		mutex_destroy(&client->read_lock);
 		mutex_destroy(&client->notifier_lock);
@@ -494,7 +493,7 @@ static int ssam_cdev_device_open(struct
 	}
 	list_add_tail(&client->node, &cdev->client_list);
 
-	up_write(&cdev->client_lock);
+	mutex_unlock(&cdev->client_lock);
 
 	stream_open(inode, filp);
 	return 0;
@@ -508,9 +507,9 @@ static int ssam_cdev_device_release(stru
 	ssam_cdev_notifier_unregister_all(client);
 
 	/* Detach client. */
-	down_write(&client->cdev->client_lock);
+	mutex_lock(&client->cdev->client_lock);
 	list_del(&client->node);
-	up_write(&client->cdev->client_lock);
+	mutex_unlock(&client->cdev->client_lock);
 
 	/* Free client. */
 	mutex_destroy(&client->write_lock);
@@ -558,17 +557,17 @@ static long ssam_cdev_device_ioctl(struc
 	long status;
 
 	/* Ensure that controller is valid for as long as we need it. */
-	if (down_read_killable(&client->cdev->lock))
+	if (mutex_lock_killable(&client->cdev->lock))
 		return -ERESTARTSYS;
 
 	if (test_bit(SSAM_CDEV_DEVICE_SHUTDOWN_BIT, &client->cdev->flags)) {
-		up_read(&client->cdev->lock);
+		mutex_unlock(&client->cdev->lock);
 		return -ENODEV;
 	}
 
 	status = __ssam_cdev_device_ioctl(client, cmd, arg);
 
-	up_read(&client->cdev->lock);
+	mutex_unlock(&client->cdev->lock);
 	return status;
 }
 
@@ -579,19 +578,19 @@ static ssize_t ssam_cdev_read(struct fil
 	unsigned int copied;
 	int status = 0;
 
-	if (down_read_killable(&cdev->lock))
+	if (mutex_lock_killable(&cdev->lock))
 		return -ERESTARTSYS;
 
 	/* Make sure we're not shut down. */
 	if (test_bit(SSAM_CDEV_DEVICE_SHUTDOWN_BIT, &cdev->flags)) {
-		up_read(&cdev->lock);
+		mutex_unlock(&cdev->lock);
 		return -ENODEV;
 	}
 
 	do {
 		/* Check availability, wait if necessary. */
 		if (kfifo_is_empty(&client->buffer)) {
-			up_read(&cdev->lock);
+			mutex_unlock(&cdev->lock);
 
 			if (file->f_flags & O_NONBLOCK)
 				return -EAGAIN;
@@ -603,19 +602,19 @@ static ssize_t ssam_cdev_read(struct fil
 			if (status < 0)
 				return status;
 
-			if (down_read_killable(&cdev->lock))
+			if (mutex_lock_killable(&cdev->lock))
 				return -ERESTARTSYS;
 
 			/* Need to check that we're not shut down again. */
 			if (test_bit(SSAM_CDEV_DEVICE_SHUTDOWN_BIT, &cdev->flags)) {
-				up_read(&cdev->lock);
+				mutex_unlock(&cdev->lock);
 				return -ENODEV;
 			}
 		}
 
 		/* Try to read from FIFO. */
 		if (mutex_lock_interruptible(&client->read_lock)) {
-			up_read(&cdev->lock);
+			mutex_unlock(&cdev->lock);
 			return -ERESTARTSYS;
 		}
 
@@ -623,18 +622,18 @@ static ssize_t ssam_cdev_read(struct fil
 		mutex_unlock(&client->read_lock);
 
 		if (status < 0) {
-			up_read(&cdev->lock);
+			mutex_unlock(&cdev->lock);
 			return status;
 		}
 
 		/* We might not have gotten anything, check this here. */
 		if (copied == 0 && (file->f_flags & O_NONBLOCK)) {
-			up_read(&cdev->lock);
+			mutex_unlock(&cdev->lock);
 			return -EAGAIN;
 		}
 	} while (copied == 0);
 
-	up_read(&cdev->lock);
+	mutex_unlock(&cdev->lock);
 	return copied;
 }
 
@@ -691,7 +690,7 @@ static int ssam_dbg_device_probe(struct
 		return -ENOMEM;
 
 	kref_init(&cdev->kref);
-	init_rwsem(&cdev->lock);
+	mutex_init(&cdev->lock);
 	cdev->ctrl = ctrl;
 	cdev->dev = &pdev->dev;
 
@@ -701,7 +700,7 @@ static int ssam_dbg_device_probe(struct
 	cdev->mdev.nodename = "surface/aggregator";
 	cdev->mdev.fops     = &ssam_controller_fops;
 
-	init_rwsem(&cdev->client_lock);
+	mutex_init(&cdev->client_lock);
 	INIT_LIST_HEAD(&cdev->client_list);
 
 	status = misc_register(&cdev->mdev);
@@ -725,7 +724,7 @@ static int ssam_dbg_device_remove(struct
 	 */
 	set_bit(SSAM_CDEV_DEVICE_SHUTDOWN_BIT, &cdev->flags);
 
-	down_write(&cdev->client_lock);
+	mutex_lock(&cdev->client_lock);
 
 	/* Remove all notifiers registered by us. */
 	list_for_each_entry(client, &cdev->client_list, node) {
@@ -742,17 +741,17 @@ static int ssam_dbg_device_remove(struct
 		wake_up_interruptible(&client->waitq);
 	}
 
-	up_write(&cdev->client_lock);
+	mutex_unlock(&cdev->client_lock);
 
 	/*
 	 * The controller is only guaranteed to be valid for as long as the
 	 * driver is bound. Remove controller so that any lingering open files
 	 * cannot access it any more after we're gone.
 	 */
-	down_write(&cdev->lock);
+	mutex_lock(&cdev->lock);
 	cdev->ctrl = NULL;
 	cdev->dev = NULL;
-	up_write(&cdev->lock);
+	mutex_unlock(&cdev->lock);
 
 	misc_deregister(&cdev->mdev);
 
diff -Npur a/drivers/platform/surface/surface_dtx.c b/drivers/platform/surface/surface_dtx.c
--- a/drivers/platform/surface/surface_dtx.c	2023-01-02 13:25:15.388099903 -0500
+++ b/drivers/platform/surface/surface_dtx.c	2023-01-02 13:19:26.098669718 -0500
@@ -22,7 +22,6 @@
 #include <linux/mutex.h>
 #include <linux/platform_device.h>
 #include <linux/poll.h>
-#include <linux/rwsem.h>
 #include <linux/slab.h>
 #include <linux/workqueue.h>
 
@@ -144,7 +143,7 @@ enum sdtx_device_state {
 
 struct sdtx_device {
 	struct kref kref;
-	struct rw_semaphore lock;         /* Guards device and controller reference. */
+	struct mutex lock;         /* Guards device and controller reference. */
 
 	struct device *dev;
 	struct ssam_controller *ctrl;
@@ -153,7 +152,7 @@ struct sdtx_device {
 	struct miscdevice mdev;
 	wait_queue_head_t waitq;
 	struct mutex write_lock;          /* Guards order of events/notifications. */
-	struct rw_semaphore client_lock;  /* Guards client list.                   */
+	struct mutex client_lock;  /* Guards client list.                   */
 	struct list_head client_list;
 
 	struct delayed_work state_work;
@@ -380,17 +379,17 @@ static long surface_dtx_ioctl(struct fil
 	struct sdtx_client *client = file->private_data;
 	long status;
 
-	if (down_read_killable(&client->ddev->lock))
+	if (mutex_lock_killable(&client->ddev->lock))
 		return -ERESTARTSYS;
 
 	if (test_bit(SDTX_DEVICE_SHUTDOWN_BIT, &client->ddev->flags)) {
-		up_read(&client->ddev->lock);
+		mutex_unlock(&client->ddev->lock);
 		return -ENODEV;
 	}
 
 	status = __surface_dtx_ioctl(client, cmd, arg);
 
-	up_read(&client->ddev->lock);
+	mutex_unlock(&client->ddev->lock);
 	return status;
 }
 
@@ -417,7 +416,7 @@ static int surface_dtx_open(struct inode
 	file->private_data = client;
 
 	/* Attach client. */
-	down_write(&ddev->client_lock);
+	mutex_lock(&ddev->client_lock);
 
 	/*
 	 * Do not add a new client if the device has been shut down. Note that
@@ -426,7 +425,7 @@ static int surface_dtx_open(struct inode
 	 * as shut down.
 	 */
 	if (test_bit(SDTX_DEVICE_SHUTDOWN_BIT, &ddev->flags)) {
-		up_write(&ddev->client_lock);
+		mutex_unlock(&ddev->client_lock);
 		mutex_destroy(&client->read_lock);
 		sdtx_device_put(client->ddev);
 		kfree(client);
@@ -434,7 +433,7 @@ static int surface_dtx_open(struct inode
 	}
 
 	list_add_tail(&client->node, &ddev->client_list);
-	up_write(&ddev->client_lock);
+	mutex_unlock(&ddev->client_lock);
 
 	stream_open(inode, file);
 	return 0;
@@ -445,9 +444,9 @@ static int surface_dtx_release(struct in
 	struct sdtx_client *client = file->private_data;
 
 	/* Detach client. */
-	down_write(&client->ddev->client_lock);
+	mutex_lock(&client->ddev->client_lock);
 	list_del(&client->node);
-	up_write(&client->ddev->client_lock);
+	mutex_unlock(&client->ddev->client_lock);
 
 	/* Free client. */
 	sdtx_device_put(client->ddev);
@@ -464,19 +463,19 @@ static ssize_t surface_dtx_read(struct f
 	unsigned int copied;
 	int status = 0;
 
-	if (down_read_killable(&ddev->lock))
+	if (mutex_lock_killable(&ddev->lock))
 		return -ERESTARTSYS;
 
 	/* Make sure we're not shut down. */
 	if (test_bit(SDTX_DEVICE_SHUTDOWN_BIT, &ddev->flags)) {
-		up_read(&ddev->lock);
+		mutex_unlock(&ddev->lock);
 		return -ENODEV;
 	}
 
 	do {
 		/* Check availability, wait if necessary. */
 		if (kfifo_is_empty(&client->buffer)) {
-			up_read(&ddev->lock);
+			mutex_unlock(&ddev->lock);
 
 			if (file->f_flags & O_NONBLOCK)
 				return -EAGAIN;
@@ -488,19 +487,19 @@ static ssize_t surface_dtx_read(struct f
 			if (status < 0)
 				return status;
 
-			if (down_read_killable(&ddev->lock))
+			if (mutex_lock_killable(&ddev->lock))
 				return -ERESTARTSYS;
 
 			/* Need to check that we're not shut down again. */
 			if (test_bit(SDTX_DEVICE_SHUTDOWN_BIT, &ddev->flags)) {
-				up_read(&ddev->lock);
+				mutex_unlock(&ddev->lock);
 				return -ENODEV;
 			}
 		}
 
 		/* Try to read from FIFO. */
 		if (mutex_lock_interruptible(&client->read_lock)) {
-			up_read(&ddev->lock);
+			mutex_unlock(&ddev->lock);
 			return -ERESTARTSYS;
 		}
 
@@ -508,18 +507,18 @@ static ssize_t surface_dtx_read(struct f
 		mutex_unlock(&client->read_lock);
 
 		if (status < 0) {
-			up_read(&ddev->lock);
+			mutex_unlock(&ddev->lock);
 			return status;
 		}
 
 		/* We might not have gotten anything, check this here. */
 		if (copied == 0 && (file->f_flags & O_NONBLOCK)) {
-			up_read(&ddev->lock);
+			mutex_unlock(&ddev->lock);
 			return -EAGAIN;
 		}
 	} while (copied == 0);
 
-	up_read(&ddev->lock);
+	mutex_unlock(&ddev->lock);
 	return copied;
 }
 
@@ -601,7 +600,7 @@ static void sdtx_push_event(struct sdtx_
 
 	lockdep_assert_held(&ddev->write_lock);
 
-	down_read(&ddev->client_lock);
+	mutex_lock(&ddev->client_lock);
 	list_for_each_entry(client, &ddev->client_list, node) {
 		if (!test_bit(SDTX_CLIENT_EVENTS_ENABLED_BIT, &client->flags))
 			continue;
@@ -613,7 +612,7 @@ static void sdtx_push_event(struct sdtx_
 
 		kill_fasync(&client->fasync, SIGIO, POLL_IN);
 	}
-	up_read(&ddev->client_lock);
+	mutex_unlock(&ddev->client_lock);
 
 	wake_up_interruptible(&ddev->waitq);
 }
@@ -947,7 +946,7 @@ static int sdtx_device_init(struct sdtx_
 
 	/* Basic initialization. */
 	kref_init(&ddev->kref);
-	init_rwsem(&ddev->lock);
+	mutex_init(&ddev->lock);
 	ddev->dev = dev;
 	ddev->ctrl = ctrl;
 
@@ -966,7 +965,7 @@ static int sdtx_device_init(struct sdtx_
 
 	init_waitqueue_head(&ddev->waitq);
 	mutex_init(&ddev->write_lock);
-	init_rwsem(&ddev->client_lock);
+	mutex_init(&ddev->client_lock);
 	INIT_LIST_HEAD(&ddev->client_list);
 
 	INIT_DELAYED_WORK(&ddev->mode_work, sdtx_device_mode_workfn);
@@ -1081,11 +1080,11 @@ static void sdtx_device_destroy(struct s
 	input_unregister_device(ddev->mode_switch);
 
 	/* Wake up async clients. */
-	down_write(&ddev->client_lock);
+	mutex_lock(&ddev->client_lock);
 	list_for_each_entry(client, &ddev->client_list, node) {
 		kill_fasync(&client->fasync, SIGIO, POLL_HUP);
 	}
-	up_write(&ddev->client_lock);
+	mutex_unlock(&ddev->client_lock);
 
 	/* Wake up blocking clients. */
 	wake_up_interruptible(&ddev->waitq);
@@ -1095,10 +1094,10 @@ static void sdtx_device_destroy(struct s
 	 * controller and device references are guaranteed to be no longer in
 	 * use.
 	 */
-	down_write(&ddev->lock);
+	mutex_lock(&ddev->lock);
 	ddev->dev = NULL;
 	ddev->ctrl = NULL;
-	up_write(&ddev->lock);
+	mutex_unlock(&ddev->lock);
 
 	/* Finally remove the misc-device. */
 	misc_deregister(&ddev->mdev);
