diff -Npur a/drivers/misc/ipts/cmd.c b/drivers/misc/ipts/cmd.c
--- a/drivers/misc/ipts/cmd.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/misc/ipts/cmd.c	2022-12-11 15:54:14.000000000 -0500
@@ -0,0 +1,144 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020-2022 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#include <linux/errno.h>
+#include <linux/types.h>
+
+#include "context.h"
+#include "spec-device.h"
+
+static int ipts_cmd_get_errno(struct ipts_response rsp, enum ipts_status expect)
+{
+	if (rsp.status == IPTS_STATUS_SUCCESS)
+		return 0;
+
+	/*
+	 * If a status code was expected, dont produce an error.
+	 */
+	if (rsp.status == expect)
+		return 0;
+
+	/*
+	 * Some devices will always return this error. It is allowed
+	 * to ignore it and to try continuing.
+	 */
+	if (rsp.status == IPTS_STATUS_COMPAT_CHECK_FAIL)
+		return 0;
+
+	/*
+	 * Return something, this is not going to be checked.
+	 * Any error will just cause the driver to stop.
+	 */
+	return -EINVAL;
+}
+
+static int _ipts_cmd_recv(struct ipts_context *ipts, enum ipts_command_code code, void *data,
+			  size_t size, bool block, enum ipts_status expect)
+{
+	int ret;
+	struct ipts_response rsp = { 0 };
+
+	if (!ipts)
+		return -EFAULT;
+
+	if (size > sizeof(rsp.payload))
+		return -EINVAL;
+
+	if (block)
+		ret = mei_cldev_recv(ipts->cldev, (u8 *)&rsp, sizeof(rsp));
+	else
+		ret = mei_cldev_recv_nonblock(ipts->cldev, (u8 *)&rsp, sizeof(rsp));
+
+	if (ret == -EAGAIN)
+		return ret;
+
+	if (ret <= 0) {
+		dev_err(ipts->dev, "Error while reading response: %d\n", ret);
+		return ret;
+	}
+
+	/*
+	 * In a response, the command code will have the most significant bit
+	 * flipped to 1. We check for this and then set the bit to 0.
+	 */
+	if ((rsp.cmd & IPTS_RSP_BIT) == 0) {
+		dev_err(ipts->dev, "Invalid command code received: 0x%02X\n", rsp.cmd);
+		return -EINVAL;
+	}
+
+	rsp.cmd = rsp.cmd & ~(IPTS_RSP_BIT);
+	if (rsp.cmd != code) {
+		dev_err(ipts->dev, "Received response to wrong command: 0x%02X\n", rsp.cmd);
+		return -EINVAL;
+	}
+
+	ret = ipts_cmd_get_errno(rsp, expect);
+	if (ret) {
+		dev_err(ipts->dev, "Command 0x%02X failed: 0x%02X\n", rsp.cmd, rsp.status);
+		return ret;
+	}
+
+	if (data && size > 0)
+		memcpy(data, rsp.payload, size);
+
+	return 0;
+}
+
+int ipts_cmd_send(struct ipts_context *ipts, enum ipts_command_code code, void *data, size_t size)
+{
+	int ret;
+	struct ipts_command cmd = { 0 };
+
+	if (!ipts)
+		return -EFAULT;
+
+	cmd.cmd = code;
+
+	if (data && size > 0)
+		memcpy(cmd.payload, data, size);
+
+	ret = mei_cldev_send(ipts->cldev, (u8 *)&cmd, sizeof(cmd.cmd) + size);
+	if (ret >= 0)
+		return 0;
+
+	dev_err(ipts->dev, "Error while sending: 0x%02X:%d\n", code, ret);
+	return ret;
+}
+
+int ipts_cmd_recv(struct ipts_context *ipts, enum ipts_command_code code, void *data, size_t size)
+{
+	return _ipts_cmd_recv(ipts, code, data, size, true, IPTS_STATUS_SUCCESS);
+}
+
+int ipts_cmd_recv_nonblock(struct ipts_context *ipts, enum ipts_command_code code, void *data,
+			   size_t size)
+{
+	return _ipts_cmd_recv(ipts, code, data, size, false, IPTS_STATUS_SUCCESS);
+}
+
+int ipts_cmd_recv_expect(struct ipts_context *ipts, enum ipts_command_code code, void *data,
+			 size_t size, enum ipts_status expect)
+{
+	return _ipts_cmd_recv(ipts, code, data, size, true, expect);
+}
+
+int ipts_cmd_run(struct ipts_context *ipts, enum ipts_command_code code, void *in, size_t insize,
+		 void *out, size_t outsize)
+{
+	int ret;
+
+	ret = ipts_cmd_send(ipts, code, in, insize);
+	if (ret)
+		return ret;
+
+	ret = ipts_cmd_recv(ipts, code, out, outsize);
+	if (ret)
+		return ret;
+
+	return 0;
+}
diff -Npur a/drivers/misc/ipts/cmd.h b/drivers/misc/ipts/cmd.h
--- a/drivers/misc/ipts/cmd.h	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/misc/ipts/cmd.h	2022-12-11 15:54:14.000000000 -0500
@@ -0,0 +1,51 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020-2022 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#ifndef IPTS_CMD_H
+#define IPTS_CMD_H
+
+#include <linux/types.h>
+
+#include "context.h"
+#include "spec-device.h"
+
+/*
+ * Executes the specified command with the given payload on the device.
+ */
+int ipts_cmd_send(struct ipts_context *ipts, enum ipts_command_code code, void *data, size_t size);
+
+/*
+ * Receives the response to the given command and copies the payload to the given buffer.
+ * This function will block until a message has been received.
+ */
+int ipts_cmd_recv(struct ipts_context *ipts, enum ipts_command_code code, void *data, size_t size);
+
+/*
+ * Receives the response to the given command and copies the payload to the given buffer.
+ * This function will not block. If no data is available, -EAGAIN will be returned.
+ */
+int ipts_cmd_recv_nonblock(struct ipts_context *ipts, enum ipts_command_code code, void *data,
+			   size_t size);
+
+/*
+ * Receives the response to the given command and copies the payload to the given buffer.
+ * This function will block until a message has been received.
+ * If the command finished with the expected status code, no error will be produced.
+ */
+int ipts_cmd_recv_expect(struct ipts_context *ipts, enum ipts_command_code code, void *data,
+			 size_t size, enum ipts_status expect);
+
+/*
+ * Executes the specified command with the given payload on the device. Then
+ * receives the response to the command and copies the payload to the given buffer.
+ * This function will block until the command has been completed.
+ */
+int ipts_cmd_run(struct ipts_context *ipts, enum ipts_command_code code, void *in, size_t insize,
+		 void *out, size_t outsize);
+
+#endif /* IPTS_CMD_H */
diff -Npur a/drivers/misc/ipts/context.h b/drivers/misc/ipts/context.h
--- a/drivers/misc/ipts/context.h	2022-12-24 14:05:14.978678975 -0500
+++ b/drivers/misc/ipts/context.h	2022-12-11 15:54:14.000000000 -0500
@@ -1,47 +1,47 @@
 /* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * Copyright (c) 2016 Intel Corporation
- * Copyright (c) 2020 Dorian Stoll
+ * Copyright (c) 2020-2022 Dorian Stoll
  *
  * Linux driver for Intel Precise Touch & Stylus
  */
 
-#ifndef _IPTS_CONTEXT_H_
-#define _IPTS_CONTEXT_H_
+#ifndef IPTS_CONTEXT_H
+#define IPTS_CONTEXT_H
 
-#include <linux/cdev.h>
+#include <linux/completion.h>
 #include <linux/device.h>
+#include <linux/hid.h>
 #include <linux/mei_cl_bus.h>
+#include <linux/mutex.h>
+#include <linux/sched.h>
 #include <linux/types.h>
 
-#include "protocol.h"
-
-enum ipts_host_status {
-	IPTS_HOST_STATUS_STARTING,
-	IPTS_HOST_STATUS_STARTED,
-	IPTS_HOST_STATUS_STOPPING,
-	IPTS_HOST_STATUS_STOPPED,
-};
-
-struct ipts_buffer_info {
-	u8 *address;
-	dma_addr_t dma_address;
-};
+#include "resources.h"
+#include "spec-device.h"
 
 struct ipts_context {
-	struct mei_cl_device *cldev;
 	struct device *dev;
+	struct mei_cl_device *cldev;
+
+	enum ipts_mode mode;
+
+	struct mutex feature_lock;
+	struct completion feature_event;
+
+	/*
+	 * These are not inside of struct ipts_resources
+	 * because they don't own the memory they point to.
+	 */
+	struct ipts_buffer feature_report;
+	struct ipts_buffer descriptor;
+
+	struct hid_device *hid;
+	struct ipts_device_info info;
+	struct ipts_resources resources;
 
-	bool restart;
-	enum ipts_host_status status;
-	struct ipts_get_device_info_rsp device_info;
-
-	struct ipts_buffer_info data[IPTS_BUFFERS];
-	struct ipts_buffer_info doorbell;
-
-	struct ipts_buffer_info feedback[IPTS_BUFFERS];
-	struct ipts_buffer_info workqueue;
-	struct ipts_buffer_info host2me;
+	struct task_struct *event_loop;
+	struct task_struct *doorbell_loop;
 };
 
-#endif /* _IPTS_CONTEXT_H_ */
+#endif /* IPTS_CONTEXT_H */
diff -Npur a/drivers/misc/ipts/control.c b/drivers/misc/ipts/control.c
--- a/drivers/misc/ipts/control.c	2022-12-24 14:05:14.978678975 -0500
+++ b/drivers/misc/ipts/control.c	2022-12-11 15:54:14.000000000 -0500
@@ -1,113 +1,300 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) 2016 Intel Corporation
- * Copyright (c) 2020 Dorian Stoll
+ * Copyright (c) 2020-2022 Dorian Stoll
  *
  * Linux driver for Intel Precise Touch & Stylus
  */
 
-#include <linux/mei_cl_bus.h>
+#include <linux/delay.h>
+#include <linux/dev_printk.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/types.h>
 
+#include "cmd.h"
 #include "context.h"
-#include "protocol.h"
+#include "control.h"
+#include "desc.h"
+#include "hid.h"
+#include "receiver.h"
 #include "resources.h"
-#include "uapi.h"
+#include "spec-data.h"
+#include "spec-device.h"
 
-int ipts_control_send(struct ipts_context *ipts, u32 code, void *payload,
-		      size_t size)
+static int ipts_control_get_device_info(struct ipts_context *ipts, struct ipts_device_info *info)
+{
+	if (!info)
+		return -EFAULT;
+
+	return ipts_cmd_run(ipts, IPTS_CMD_GET_DEVICE_INFO, NULL, 0, info, sizeof(*info));
+}
+
+static int ipts_control_set_mode(struct ipts_context *ipts, enum ipts_mode mode)
+{
+	struct ipts_set_mode cmd = { 0 };
+
+	cmd.mode = mode;
+	return ipts_cmd_run(ipts, IPTS_CMD_SET_MODE, &cmd, sizeof(cmd), NULL, 0);
+}
+
+static int ipts_control_set_mem_window(struct ipts_context *ipts, struct ipts_resources *res)
+{
+	struct ipts_mem_window cmd = { 0 };
+
+	if (!res)
+		return -EFAULT;
+
+	for (int i = 0; i < IPTS_BUFFERS; i++) {
+		cmd.data_addr_lower[i] = lower_32_bits(res->data[i].dma_address);
+		cmd.data_addr_upper[i] = upper_32_bits(res->data[i].dma_address);
+		cmd.feedback_addr_lower[i] = lower_32_bits(res->feedback[i].dma_address);
+		cmd.feedback_addr_upper[i] = upper_32_bits(res->feedback[i].dma_address);
+	}
+
+	cmd.workqueue_addr_lower = lower_32_bits(res->workqueue.dma_address);
+	cmd.workqueue_addr_upper = upper_32_bits(res->workqueue.dma_address);
+
+	cmd.doorbell_addr_lower = lower_32_bits(res->doorbell.dma_address);
+	cmd.doorbell_addr_upper = upper_32_bits(res->doorbell.dma_address);
+
+	cmd.hid2me_addr_lower = lower_32_bits(res->hid2me.dma_address);
+	cmd.hid2me_addr_upper = upper_32_bits(res->hid2me.dma_address);
+
+	cmd.workqueue_size = IPTS_WORKQUEUE_SIZE;
+	cmd.workqueue_item_size = IPTS_WORKQUEUE_ITEM_SIZE;
+
+	return ipts_cmd_run(ipts, IPTS_CMD_SET_MEM_WINDOW, &cmd, sizeof(cmd), NULL, 0);
+}
+
+static int ipts_control_reset_sensor(struct ipts_context *ipts)
+{
+	struct ipts_feedback_header *header;
+
+	if (!ipts)
+		return -EFAULT;
+
+	memset(ipts->resources.hid2me.address, 0, ipts->resources.hid2me.size);
+	header = (struct ipts_feedback_header *)ipts->resources.hid2me.address;
+
+	header->cmd_type = IPTS_FEEDBACK_CMD_TYPE_SOFT_RESET;
+	header->buffer = IPTS_HID2ME_BUFFER;
+
+	return ipts_control_send_feedback(ipts, IPTS_HID2ME_BUFFER);
+}
+
+static int ipts_control_get_descriptor(struct ipts_context *ipts)
 {
 	int ret;
-	struct ipts_command cmd;
+	struct ipts_data_header *header;
+	struct ipts_get_descriptor cmd = { 0 };
+
+	if (!ipts)
+		return -EFAULT;
+
+	memset(ipts->resources.descriptor.address, 0, ipts->resources.descriptor.size);
 
-	memset(&cmd, 0, sizeof(struct ipts_command));
-	cmd.code = code;
+	cmd.addr_lower = lower_32_bits(ipts->resources.descriptor.dma_address);
+	cmd.addr_upper = upper_32_bits(ipts->resources.descriptor.dma_address);
+	cmd.magic = 8;
 
-	if (payload && size > 0)
-		memcpy(&cmd.payload, payload, size);
+	ret = ipts_cmd_run(ipts, IPTS_CMD_GET_DESCRIPTOR, &cmd, sizeof(cmd), NULL, 0);
+	if (ret)
+		return ret;
+
+	header = (struct ipts_data_header *)ipts->resources.descriptor.address;
+
+	if (header->type == IPTS_DATA_TYPE_DESCRIPTOR) {
+		ipts->descriptor.address = &header->data[8];
+		ipts->descriptor.size = header->size - 8;
 
-	ret = mei_cldev_send(ipts->cldev, (u8 *)&cmd, sizeof(cmd.code) + size);
-	if (ret >= 0)
 		return 0;
+	}
 
-	/*
-	 * During shutdown the device might get pulled away from below our feet.
-	 * Dont log an error in this case, because it will confuse people.
-	 */
-	if (ret != -ENODEV || ipts->status != IPTS_HOST_STATUS_STOPPING)
-		dev_err(ipts->dev, "Error while sending: 0x%X:%d\n", code, ret);
+	return -EINVAL;
+}
 
-	return ret;
+int ipts_control_request_flush(struct ipts_context *ipts)
+{
+	struct ipts_quiesce_io cmd = { 0 };
+
+	return ipts_cmd_send(ipts, IPTS_CMD_QUIESCE_IO, &cmd, sizeof(cmd));
+}
+
+int ipts_control_wait_flush(struct ipts_context *ipts)
+{
+	return ipts_cmd_recv(ipts, IPTS_CMD_QUIESCE_IO, NULL, 0);
+}
+
+int ipts_control_request_data(struct ipts_context *ipts)
+{
+	return ipts_cmd_send(ipts, IPTS_CMD_READY_FOR_DATA, NULL, 0);
+}
+
+int ipts_control_wait_data(struct ipts_context *ipts, bool shutdown)
+{
+	if (!shutdown)
+		return ipts_cmd_recv_nonblock(ipts, IPTS_CMD_READY_FOR_DATA, NULL, 0);
+
+	return ipts_cmd_recv_expect(ipts, IPTS_CMD_READY_FOR_DATA, NULL, 0,
+				    IPTS_STATUS_SENSOR_DISABLED);
 }
 
 int ipts_control_send_feedback(struct ipts_context *ipts, u32 buffer)
 {
-	struct ipts_feedback_cmd cmd;
+	int ret;
+	struct ipts_feedback cmd = { 0 };
 
-	memset(&cmd, 0, sizeof(struct ipts_feedback_cmd));
 	cmd.buffer = buffer;
 
-	return ipts_control_send(ipts, IPTS_CMD_FEEDBACK, &cmd,
-				 sizeof(struct ipts_feedback_cmd));
+	ret = ipts_cmd_send(ipts, IPTS_CMD_FEEDBACK, &cmd, sizeof(cmd));
+	if (ret)
+		return ret;
+
+	return ipts_cmd_recv_expect(ipts, IPTS_CMD_FEEDBACK, NULL, 0, IPTS_STATUS_INVALID_PARAMS);
 }
 
-int ipts_control_set_feature(struct ipts_context *ipts, u8 report, u8 value)
+int ipts_control_refill_buffer(struct ipts_context *ipts, u32 buffer)
 {
-	struct ipts_feedback_buffer *feedback;
-
-	memset(ipts->host2me.address, 0, ipts->device_info.feedback_size);
-	feedback = (struct ipts_feedback_buffer *)ipts->host2me.address;
+	if (!ipts)
+		return -EFAULT;
 
-	feedback->cmd_type = IPTS_FEEDBACK_CMD_TYPE_NONE;
-	feedback->data_type = IPTS_FEEDBACK_DATA_TYPE_SET_FEATURES;
-	feedback->buffer = IPTS_HOST2ME_BUFFER;
-	feedback->size = 2;
-	feedback->payload[0] = report;
-	feedback->payload[1] = value;
+	/*
+	 * IPTS expects structured data in the feedback buffer matching the buffer that will be refilled.
+	 * We don't know what that data looks like, so we just keep the buffer empty.
+	 * This results in an INVALID_PARAMS error, but the buffer gets refilled without an issue.
+	 * Sending a minimal structure with the buffer ID fixes the error, but breaks refilling
+	 * the buffers on some devices.
+	 */
 
-	return ipts_control_send_feedback(ipts, IPTS_HOST2ME_BUFFER);
+	return ipts_control_send_feedback(ipts, buffer);
 }
 
 int ipts_control_start(struct ipts_context *ipts)
 {
-	if (ipts->status != IPTS_HOST_STATUS_STOPPED)
-		return -EBUSY;
+	int ret;
+	struct ipts_device_info info;
+
+	if (!ipts)
+		return -EFAULT;
 
 	dev_info(ipts->dev, "Starting IPTS\n");
-	ipts->status = IPTS_HOST_STATUS_STARTING;
-	ipts->restart = false;
 
-	ipts_uapi_link(ipts);
-	return ipts_control_send(ipts, IPTS_CMD_GET_DEVICE_INFO, NULL, 0);
+	ret = ipts_control_get_device_info(ipts, &info);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to get device info: %d\n", ret);
+		return ret;
+	}
+
+	ipts->info = info;
+
+	ret = ipts_resources_init(&ipts->resources, ipts->dev, info.data_size, info.feedback_size);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to allocate buffers: %d", ret);
+		return ret;
+	}
+
+	dev_info(ipts->dev, "IPTS EDS Version: %d\n", info.intf_eds);
+
+	/*
+	 * Handle newer devices
+	 */
+	if (info.intf_eds > 1) {
+		/*
+		 * Fetching the descriptor will only work on newer devices.
+		 * For older devices, a fallback descriptor will be used.
+		 */
+		ret = ipts_control_get_descriptor(ipts);
+		if (ret) {
+			dev_err(ipts->dev, "Failed to fetch HID descriptor: %d\n", ret);
+			return ret;
+		}
+
+		/*
+		 * Newer devices can be directly initialized in doorbell mode.
+		 */
+		ipts->mode = IPTS_MODE_DOORBELL;
+	}
+
+	ret = ipts_control_set_mode(ipts, ipts->mode);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to set mode: %d\n", ret);
+		return ret;
+	}
+
+	ret = ipts_control_set_mem_window(ipts, &ipts->resources);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to set memory window: %d\n", ret);
+		return ret;
+	}
+
+	ipts_receiver_start(ipts);
+
+	ret = ipts_control_request_data(ipts);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to request data: %d\n", ret);
+		return ret;
+	}
+
+	ret = ipts_hid_init(ipts, info);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to initialize HID device: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
 }
 
-int ipts_control_stop(struct ipts_context *ipts)
+static int _ipts_control_stop(struct ipts_context *ipts)
 {
 	int ret;
 
-	if (ipts->status == IPTS_HOST_STATUS_STOPPING)
-		return -EBUSY;
-
-	if (ipts->status == IPTS_HOST_STATUS_STOPPED)
-		return -EBUSY;
+	if (!ipts)
+		return -EFAULT;
 
 	dev_info(ipts->dev, "Stopping IPTS\n");
-	ipts->status = IPTS_HOST_STATUS_STOPPING;
+	ipts_receiver_stop(ipts);
 
-	ipts_uapi_unlink();
-	ipts_resources_free(ipts);
+	ret = ipts_control_reset_sensor(ipts);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to reset sensor: %d\n", ret);
+		return ret;
+	}
 
-	ret = ipts_control_send_feedback(ipts, 0);
-	if (ret == -ENODEV)
-		ipts->status = IPTS_HOST_STATUS_STOPPED;
+	ipts_resources_free(&ipts->resources);
+	return 0;
+}
+
+int ipts_control_stop(struct ipts_context *ipts)
+{
+	int ret;
 
-	return ret;
+	ret = _ipts_control_stop(ipts);
+	if (ret)
+		return ret;
+
+	ipts_hid_free(ipts);
+
+	return 0;
 }
 
 int ipts_control_restart(struct ipts_context *ipts)
 {
-	if (ipts->restart)
-		return -EBUSY;
+	int ret;
+
+	ret = _ipts_control_stop(ipts);
+	if (ret)
+		return ret;
+
+	/*
+	 * Give the sensor some time to come back from resetting
+	 */
+	msleep(1000);
+
+	ret = ipts_control_start(ipts);
+	if (ret)
+		return ret;
 
-	ipts->restart = true;
-	return ipts_control_stop(ipts);
+	return 0;
 }
diff -Npur a/drivers/misc/ipts/control.h b/drivers/misc/ipts/control.h
--- a/drivers/misc/ipts/control.h	2022-12-24 14:05:14.978678975 -0500
+++ b/drivers/misc/ipts/control.h	2022-12-11 15:54:14.000000000 -0500
@@ -1,24 +1,73 @@
 /* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * Copyright (c) 2016 Intel Corporation
- * Copyright (c) 2020 Dorian Stoll
+ * Copyright (c) 2020-2022 Dorian Stoll
  *
  * Linux driver for Intel Precise Touch & Stylus
  */
 
-#ifndef _IPTS_CONTROL_H_
-#define _IPTS_CONTROL_H_
+#ifndef IPTS_CONTROL_H
+#define IPTS_CONTROL_H
 
 #include <linux/types.h>
 
 #include "context.h"
+#include "spec-device.h"
 
-int ipts_control_send(struct ipts_context *ipts, u32 cmd, void *payload,
-		      size_t size);
+/*
+ * Sends a request to stop the data flow to the device.
+ * All outstanding data needs to be acknowledged using
+ * feedback before the request can be finalized.
+ */
+int ipts_control_request_flush(struct ipts_context *ipts);
+
+/*
+ * Waits until the flushing request has been finalized.
+ */
+int ipts_control_wait_flush(struct ipts_context *ipts);
+
+/*
+ * Notify the device that the driver can receive new data.
+ */
+int ipts_control_request_data(struct ipts_context *ipts);
+
+/*
+ * Wait until new data is available on the device.
+ * In doorbell mode, this function will never return while the data
+ * flow is active. Instead, the doorbell will be incremented when new
+ * data is available.
+ *
+ * If shutdown == true, the function will block, and errors that are
+ * produced by the device due to a disabled sensor will be ignored.
+ *
+ * If shutdown == false, the function will not block. If no data is
+ * available, -EAGAIN will be returned.
+ */
+int ipts_control_wait_data(struct ipts_context *ipts, bool shutdown);
+
+/*
+ * Submits the given feedback buffer to the hardware.
+ */
 int ipts_control_send_feedback(struct ipts_context *ipts, u32 buffer);
-int ipts_control_set_feature(struct ipts_context *ipts, u8 report, u8 value);
+
+/*
+ * Acknowledges that the data in a buffer has been processed.
+ */
+int ipts_control_refill_buffer(struct ipts_context *ipts, u32 buffer);
+
+/*
+ * Initializes the IPTS device and starts the data flow.
+ */
 int ipts_control_start(struct ipts_context *ipts);
-int ipts_control_restart(struct ipts_context *ipts);
+
+/*
+ * Stops the data flow and resets the device.
+ */
 int ipts_control_stop(struct ipts_context *ipts);
 
-#endif /* _IPTS_CONTROL_H_ */
+/*
+ * Stops the device and immideately starts it again.
+ */
+int ipts_control_restart(struct ipts_context *ipts);
+
+#endif /* IPTS_CONTROL_H */
diff -Npur a/drivers/misc/ipts/desc.h b/drivers/misc/ipts/desc.h
--- a/drivers/misc/ipts/desc.h	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/misc/ipts/desc.h	2022-12-11 15:54:14.000000000 -0500
@@ -0,0 +1,81 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2022 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#ifndef IPTS_DESC_H
+#define IPTS_DESC_H
+
+#include <linux/types.h>
+
+#define IPTS_HID_REPORT_SINGLETOUCH 64
+#define IPTS_HID_REPORT_DATA	    65
+#define IPTS_HID_REPORT_SET_MODE    66
+
+#define IPTS_HID_REPORT_DATA_SIZE 7485
+
+/*
+ * HID descriptor for singletouch data.
+ * This descriptor should be present on all IPTS devices.
+ */
+static const u8 ipts_singletouch_descriptor[] = {
+	0x05, 0x0D,	  /*  Usage Page (Digitizer),            */
+	0x09, 0x04,	  /*  Usage (Touchscreen),               */
+	0xA1, 0x01,	  /*  Collection (Application),          */
+	0x85, 0x40,	  /*      Report ID (64),                */
+	0x09, 0x42,	  /*      Usage (Tip Switch),            */
+	0x15, 0x00,	  /*      Logical Minimum (0),           */
+	0x25, 0x01,	  /*      Logical Maximum (1),           */
+	0x75, 0x01,	  /*      Report Size (1),               */
+	0x95, 0x01,	  /*      Report Count (1),              */
+	0x81, 0x02,	  /*      Input (Variable),              */
+	0x95, 0x07,	  /*      Report Count (7),              */
+	0x81, 0x03,	  /*      Input (Constant, Variable),    */
+	0x05, 0x01,	  /*      Usage Page (Desktop),          */
+	0x09, 0x30,	  /*      Usage (X),                     */
+	0x75, 0x10,	  /*      Report Size (16),              */
+	0x95, 0x01,	  /*      Report Count (1),              */
+	0xA4,		  /*      Push,                          */
+	0x55, 0x0E,	  /*      Unit Exponent (14),            */
+	0x65, 0x11,	  /*      Unit (Centimeter),             */
+	0x46, 0x76, 0x0B, /*      Physical Maximum (2934),       */
+	0x26, 0xFF, 0x7F, /*      Logical Maximum (32767),       */
+	0x81, 0x02,	  /*      Input (Variable),              */
+	0x09, 0x31,	  /*      Usage (Y),                     */
+	0x46, 0x74, 0x06, /*      Physical Maximum (1652),       */
+	0x26, 0xFF, 0x7F, /*      Logical Maximum (32767),       */
+	0x81, 0x02,	  /*      Input (Variable),              */
+	0xB4,		  /*      Pop,                           */
+	0xC0,		  /*  End Collection                     */
+};
+
+/*
+ * Fallback HID descriptor for older devices that do not have
+ * the ability to query their HID descriptor.
+ */
+static const u8 ipts_fallback_descriptor[] = {
+	0x05, 0x0D,	  /*  Usage Page (Digitizer),            */
+	0x09, 0x0F,	  /*  Usage (Capacitive Hm Digitizer),   */
+	0xA1, 0x01,	  /*  Collection (Application),          */
+	0x85, 0x41,	  /*      Report ID (65),                */
+	0x09, 0x56,	  /*      Usage (Scan Time),             */
+	0x95, 0x01,	  /*      Report Count (1),              */
+	0x75, 0x10,	  /*      Report Size (16),              */
+	0x81, 0x02,	  /*      Input (Variable),              */
+	0x09, 0x61,	  /*      Usage (Gesture Char Quality),  */
+	0x75, 0x08,	  /*      Report Size (8),               */
+	0x96, 0x3D, 0x1D, /*      Report Count (7485),           */
+	0x81, 0x03,	  /*      Input (Constant, Variable),    */
+	0x85, 0x42,	  /*      Report ID (66),                */
+	0x06, 0x00, 0xFF, /*      Usage Page (FF00h),            */
+	0x09, 0xC8,	  /*      Usage (C8h),                   */
+	0x75, 0x08,	  /*      Report Size (8),               */
+	0x95, 0x01,	  /*      Report Count (1),              */
+	0xB1, 0x02,	  /*      Feature (Variable),            */
+	0xC0,		  /*  End Collection,                    */
+};
+
+#endif /* IPTS_DESC_H */
diff -Npur a/drivers/misc/ipts/hid.c b/drivers/misc/ipts/hid.c
--- a/drivers/misc/ipts/hid.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/misc/ipts/hid.c	2022-12-11 15:54:14.000000000 -0500
@@ -0,0 +1,347 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020-2022 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#include <linux/completion.h>
+#include <linux/gfp.h>
+#include <linux/hid.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+
+#include "context.h"
+#include "control.h"
+#include "desc.h"
+#include "hid.h"
+#include "spec-data.h"
+#include "spec-device.h"
+#include "spec-hid.h"
+
+static int ipts_hid_start(struct hid_device *hid)
+{
+	return 0;
+}
+
+static void ipts_hid_stop(struct hid_device *hid)
+{
+}
+
+static int ipts_hid_hid2me_feedback(struct ipts_context *ipts, enum ipts_feedback_data_type type,
+				    void *data, size_t size)
+{
+	struct ipts_feedback_header *header;
+
+	if (!ipts)
+		return -EFAULT;
+
+	memset(ipts->resources.hid2me.address, 0, ipts->resources.hid2me.size);
+	header = (struct ipts_feedback_header *)ipts->resources.hid2me.address;
+
+	header->cmd_type = IPTS_FEEDBACK_CMD_TYPE_NONE;
+	header->buffer = IPTS_HID2ME_BUFFER;
+	header->data_type = type;
+	header->size = size;
+
+	if (size + sizeof(*header) > ipts->resources.hid2me.size)
+		return -EINVAL;
+
+	if (data && size > 0)
+		memcpy(header->payload, data, size);
+
+	return ipts_control_send_feedback(ipts, IPTS_HID2ME_BUFFER);
+}
+
+static int ipts_hid_switch_mode(struct ipts_context *ipts, enum ipts_mode mode)
+{
+	if (!ipts)
+		return -EFAULT;
+
+	if (ipts->mode == mode)
+		return 0;
+
+	/*
+	 * This is only allowed on older devices.
+	 */
+	if (ipts->info.intf_eds > 1)
+		return 0;
+
+	ipts->mode = mode;
+	return ipts_control_restart(ipts);
+}
+
+static int ipts_hid_parse(struct hid_device *hid)
+{
+	int ret;
+	u8 *buffer;
+	size_t size;
+	struct ipts_context *ipts;
+	bool has_native_descriptor;
+
+	if (!hid)
+		return -EFAULT;
+
+	ipts = hid->driver_data;
+
+	if (!ipts)
+		return -EFAULT;
+
+	size = sizeof(ipts_singletouch_descriptor);
+	has_native_descriptor = ipts->descriptor.address && ipts->descriptor.size > 0;
+
+	if (has_native_descriptor)
+		size += ipts->descriptor.size;
+	else
+		size += sizeof(ipts_fallback_descriptor);
+
+	buffer = kzalloc(size, GFP_KERNEL);
+	memcpy(buffer, ipts_singletouch_descriptor, sizeof(ipts_singletouch_descriptor));
+
+	if (has_native_descriptor) {
+		memcpy(&buffer[sizeof(ipts_singletouch_descriptor)], ipts->descriptor.address,
+		       ipts->descriptor.size);
+	} else {
+		memcpy(&buffer[sizeof(ipts_singletouch_descriptor)], ipts_fallback_descriptor,
+		       sizeof(ipts_fallback_descriptor));
+	}
+
+	ret = hid_parse_report(hid, buffer, size);
+	kfree(buffer);
+
+	if (ret) {
+		dev_err(ipts->dev, "Failed to parse HID descriptor: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ipts_hid_get_feature(struct ipts_context *ipts, unsigned char reportnum, __u8 *buf,
+				size_t size, enum ipts_feedback_data_type type)
+{
+	int ret;
+
+	mutex_lock(&ipts->feature_lock);
+
+	memset(buf, 0, size);
+	buf[0] = reportnum;
+
+	memset(&ipts->feature_report, 0, sizeof(ipts->feature_report));
+	reinit_completion(&ipts->feature_event);
+
+	ret = ipts_hid_hid2me_feedback(ipts, type, buf, size);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to send hid2me feedback: %d\n", ret);
+		goto out;
+	}
+
+	ret = wait_for_completion_timeout(&ipts->feature_event, msecs_to_jiffies(5000));
+	if (ret == 0) {
+		dev_warn(ipts->dev, "GET_FEATURES timed out!\n");
+		ret = -EIO;
+		goto out;
+	}
+
+	if (!ipts->feature_report.address) {
+		ret = -EFAULT;
+		goto out;
+	}
+
+	if (ipts->feature_report.size > size) {
+		ret = -ETOOSMALL;
+		goto out;
+	}
+
+	ret = ipts->feature_report.size;
+	memcpy(buf, ipts->feature_report.address, ipts->feature_report.size);
+
+out:
+	mutex_unlock(&ipts->feature_lock);
+	return ret;
+}
+
+static int ipts_hid_set_feature(struct ipts_context *ipts, unsigned char reportnum, __u8 *buf,
+				size_t size, enum ipts_feedback_data_type type)
+{
+	int ret;
+
+	buf[0] = reportnum;
+
+	ret = ipts_hid_hid2me_feedback(ipts, type, buf, size);
+	if (ret)
+		dev_err(ipts->dev, "Failed to send hid2me feedback: %d\n", ret);
+
+	return ret;
+}
+
+static int ipts_hid_raw_request(struct hid_device *hid, unsigned char reportnum, __u8 *buf,
+				size_t size, unsigned char rtype, int reqtype)
+{
+	int ret;
+	enum ipts_feedback_data_type type;
+	struct ipts_context *ipts;
+
+	if (!hid)
+		return -EFAULT;
+
+	ipts = hid->driver_data;
+
+	if (!ipts)
+		return -EFAULT;
+
+	if (!buf)
+		return -EFAULT;
+
+	if (rtype == HID_OUTPUT_REPORT && reqtype == HID_REQ_SET_REPORT)
+		type = IPTS_FEEDBACK_DATA_TYPE_OUTPUT_REPORT;
+	else if (rtype == HID_FEATURE_REPORT && reqtype == HID_REQ_GET_REPORT)
+		type = IPTS_FEEDBACK_DATA_TYPE_GET_FEATURES;
+	else if (rtype == HID_FEATURE_REPORT && reqtype == HID_REQ_SET_REPORT)
+		type = IPTS_FEEDBACK_DATA_TYPE_SET_FEATURES;
+	else
+		return -EIO;
+
+	// Implemente mode switching report for older devices without native HID support
+	if (type == IPTS_FEEDBACK_DATA_TYPE_SET_FEATURES && reportnum == IPTS_HID_REPORT_SET_MODE) {
+		ret = ipts_hid_switch_mode(ipts, buf[1]);
+		if (ret) {
+			dev_err(ipts->dev, "Failed to switch modes: %d\n", ret);
+			return ret;
+		}
+	}
+
+	if (reqtype == HID_REQ_GET_REPORT)
+		return ipts_hid_get_feature(ipts, reportnum, buf, size, type);
+	else
+		return ipts_hid_set_feature(ipts, reportnum, buf, size, type);
+}
+
+static int ipts_hid_output_report(struct hid_device *hid, __u8 *data, size_t size)
+{
+	struct ipts_context *ipts;
+
+	if (!hid)
+		return -EFAULT;
+
+	ipts = hid->driver_data;
+
+	if (!ipts)
+		return -EFAULT;
+
+	if (!data)
+		return -EFAULT;
+
+	return ipts_hid_hid2me_feedback(ipts, IPTS_FEEDBACK_DATA_TYPE_OUTPUT_REPORT, data, size);
+}
+
+static struct hid_ll_driver ipts_hid_driver = {
+	.start = ipts_hid_start,
+	.stop = ipts_hid_stop,
+	.open = ipts_hid_start,
+	.close = ipts_hid_stop,
+	.parse = ipts_hid_parse,
+	.raw_request = ipts_hid_raw_request,
+	.output_report = ipts_hid_output_report,
+};
+
+int ipts_hid_input_data(struct ipts_context *ipts, int buffer)
+{
+	int ret;
+	u8 *temp;
+	struct ipts_hid_header *frame;
+	struct ipts_data_header *header;
+
+	if (!ipts)
+		return -EFAULT;
+
+	if (!ipts->hid)
+		return -ENODEV;
+
+	header = (struct ipts_data_header *)ipts->resources.data[buffer].address;
+
+	if (header->size == 0)
+		return 0;
+
+	if (header->type == IPTS_DATA_TYPE_HID)
+		return hid_input_report(ipts->hid, HID_INPUT_REPORT, header->data, header->size, 1);
+
+	if (header->type == IPTS_DATA_TYPE_GET_FEATURES) {
+		ipts->feature_report.address = header->data;
+		ipts->feature_report.size = header->size;
+
+		complete_all(&ipts->feature_event);
+		return 0;
+	}
+
+	if (header->type != IPTS_DATA_TYPE_FRAME)
+		return 0;
+
+	if (header->size + 3 + sizeof(struct ipts_hid_header) > IPTS_HID_REPORT_DATA_SIZE)
+		return -ERANGE;
+
+	temp = kzalloc(IPTS_HID_REPORT_DATA_SIZE, GFP_KERNEL);
+	if (!temp)
+		return -ENOMEM;
+
+	/*
+	 * Synthesize a HID report matching the devices that natively send HID reports
+	 */
+	temp[0] = IPTS_HID_REPORT_DATA;
+
+	frame = (struct ipts_hid_header *)&temp[3];
+	frame->type = IPTS_HID_FRAME_TYPE_RAW;
+	frame->size = header->size + sizeof(*frame);
+
+	memcpy(frame->data, header->data, header->size);
+
+	ret = hid_input_report(ipts->hid, HID_INPUT_REPORT, temp, IPTS_HID_REPORT_DATA_SIZE, 1);
+	kfree(temp);
+
+	return ret;
+}
+
+int ipts_hid_init(struct ipts_context *ipts, struct ipts_device_info info)
+{
+	int ret;
+
+	if (!ipts)
+		return -EFAULT;
+
+	if (ipts->hid)
+		return 0;
+
+	ipts->hid = hid_allocate_device();
+	if (IS_ERR(ipts->hid)) {
+		dev_err(ipts->dev, "Failed to allocate HID device: %ld\n", PTR_ERR(ipts->hid));
+		return PTR_ERR(ipts->hid);
+	}
+
+	ipts->hid->driver_data = ipts;
+	ipts->hid->dev.parent = ipts->dev;
+	ipts->hid->ll_driver = &ipts_hid_driver;
+
+	ipts->hid->vendor = info.vendor;
+	ipts->hid->product = info.product;
+	ipts->hid->group = HID_GROUP_MULTITOUCH;
+
+	snprintf(ipts->hid->name, sizeof(ipts->hid->name), "IPTS %04X:%04X", info.vendor,
+		 info.product);
+
+	ret = hid_add_device(ipts->hid);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to add HID device: %d\n", ret);
+		ipts_hid_free(ipts);
+		return ret;
+	}
+
+	return 0;
+}
+
+void ipts_hid_free(struct ipts_context *ipts)
+{
+	hid_destroy_device(ipts->hid);
+	ipts->hid = NULL;
+}
diff -Npur a/drivers/misc/ipts/hid.h b/drivers/misc/ipts/hid.h
--- a/drivers/misc/ipts/hid.h	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/misc/ipts/hid.h	2022-12-11 15:54:14.000000000 -0500
@@ -0,0 +1,22 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020-2022 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#ifndef IPTS_HID_H
+#define IPTS_HID_H
+
+#include <linux/types.h>
+
+#include "context.h"
+#include "spec-device.h"
+
+int ipts_hid_input_data(struct ipts_context *ipts, int buffer);
+
+int ipts_hid_init(struct ipts_context *ipts, struct ipts_device_info info);
+void ipts_hid_free(struct ipts_context *ipts);
+
+#endif /* IPTS_HID_H */
diff -Npur a/drivers/misc/ipts/Kconfig b/drivers/misc/ipts/Kconfig
--- a/drivers/misc/ipts/Kconfig	2022-12-24 14:05:14.978678975 -0500
+++ b/drivers/misc/ipts/Kconfig	2022-12-11 15:54:14.000000000 -0500
@@ -1,8 +1,9 @@
 # SPDX-License-Identifier: GPL-2.0-or-later
 
-config MISC_IPTS
+config HID_IPTS
 	tristate "Intel Precise Touch & Stylus"
 	depends on INTEL_MEI
+	depends on HID
 	help
 	  Say Y here if your system has a touchscreen using Intels
 	  Precise Touch & Stylus (IPTS) technology.
@@ -11,7 +12,3 @@ config MISC_IPTS
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called ipts.
-
-	  Building this driver alone will not give you a working touchscreen.
-	  It only exposed a userspace API that can be used by a daemon to
-	  receive and process data from the touchscreen hardware.
diff -Npur a/drivers/misc/ipts/Makefile b/drivers/misc/ipts/Makefile
--- a/drivers/misc/ipts/Makefile	2022-12-24 14:05:14.978678975 -0500
+++ b/drivers/misc/ipts/Makefile	2022-12-11 15:54:14.000000000 -0500
@@ -3,10 +3,10 @@
 # Makefile for the IPTS touchscreen driver
 #
 
-obj-$(CONFIG_MISC_IPTS) += ipts.o
-ipts-objs := control.o
+obj-$(CONFIG_HID_IPTS) += ipts.o
+ipts-objs := cmd.o
+ipts-objs += control.o
+ipts-objs += hid.o
 ipts-objs += mei.o
 ipts-objs += receiver.o
 ipts-objs += resources.o
-ipts-objs += uapi.o
-
diff -Npur a/drivers/misc/ipts/mei.c b/drivers/misc/ipts/mei.c
--- a/drivers/misc/ipts/mei.c	2022-12-24 14:05:14.978678975 -0500
+++ b/drivers/misc/ipts/mei.c	2022-12-11 15:54:14.000000000 -0500
@@ -1,44 +1,51 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) 2016 Intel Corporation
- * Copyright (c) 2020 Dorian Stoll
+ * Copyright (c) 2020-2022 Dorian Stoll
  *
  * Linux driver for Intel Precise Touch & Stylus
  */
 
+#include <linux/completion.h>
 #include <linux/delay.h>
+#include <linux/device.h>
 #include <linux/dma-mapping.h>
 #include <linux/mei_cl_bus.h>
 #include <linux/mod_devicetable.h>
 #include <linux/module.h>
+#include <linux/mutex.h>
 #include <linux/slab.h>
+#include <linux/stddef.h>
+#include <linux/types.h>
 
 #include "context.h"
 #include "control.h"
-#include "protocol.h"
 #include "receiver.h"
-#include "uapi.h"
+#include "spec-device.h"
+
+/*
+ * The MEI client ID for IPTS functionality.
+ */
+#define IPTS_MEI_UUID                                                                              \
+	UUID_LE(0x3e8d0870, 0x271a, 0x4208, 0x8e, 0xb5, 0x9a, 0xcb, 0x94, 0x02, 0xae, 0x04)
 
 static int ipts_mei_set_dma_mask(struct mei_cl_device *cldev)
 {
-	int ret;
-
-	ret = dma_coerce_mask_and_coherent(&cldev->dev, DMA_BIT_MASK(64));
-	if (!ret)
+	if (!dma_coerce_mask_and_coherent(&cldev->dev, DMA_BIT_MASK(64)))
 		return 0;
 
 	return dma_coerce_mask_and_coherent(&cldev->dev, DMA_BIT_MASK(32));
 }
 
-static int ipts_mei_probe(struct mei_cl_device *cldev,
-			  const struct mei_cl_device_id *id)
+static int ipts_mei_probe(struct mei_cl_device *cldev, const struct mei_cl_device_id *id)
 {
 	int ret;
 	struct ipts_context *ipts;
 
-	if (ipts_mei_set_dma_mask(cldev)) {
-		dev_err(&cldev->dev, "Failed to set DMA mask for IPTS\n");
-		return -EFAULT;
+	ret = ipts_mei_set_dma_mask(cldev);
+	if (ret) {
+		dev_err(&cldev->dev, "Failed to set DMA mask for IPTS: %d\n", ret);
+		return ret;
 	}
 
 	ret = mei_cldev_enable(cldev);
@@ -47,7 +54,7 @@ static int ipts_mei_probe(struct mei_cl_
 		return ret;
 	}
 
-	ipts = kzalloc(sizeof(*ipts), GFP_KERNEL);
+	ipts = devm_kzalloc(&cldev->dev, sizeof(*ipts), GFP_KERNEL);
 	if (!ipts) {
 		mei_cldev_disable(cldev);
 		return -ENOMEM;
@@ -55,34 +62,36 @@ static int ipts_mei_probe(struct mei_cl_
 
 	ipts->cldev = cldev;
 	ipts->dev = &cldev->dev;
-	ipts->status = IPTS_HOST_STATUS_STOPPED;
+	ipts->mode = IPTS_MODE_EVENT;
+
+	mutex_init(&ipts->feature_lock);
+	init_completion(&ipts->feature_event);
 
 	mei_cldev_set_drvdata(cldev, ipts);
-	mei_cldev_register_rx_cb(cldev, ipts_receiver_callback);
 
-	return ipts_control_start(ipts);
+	ret = ipts_control_start(ipts);
+	if (ret) {
+		dev_err(&cldev->dev, "Failed to start IPTS: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
 }
 
 static void ipts_mei_remove(struct mei_cl_device *cldev)
 {
-	int i;
+	int ret;
 	struct ipts_context *ipts = mei_cldev_get_drvdata(cldev);
 
-	ipts_control_stop(ipts);
-
-	for (i = 0; i < 20; i++) {
-		if (ipts->status == IPTS_HOST_STATUS_STOPPED)
-			break;
-
-		msleep(25);
-	}
+	ret = ipts_control_stop(ipts);
+	if (ret)
+		dev_err(&cldev->dev, "Failed to stop IPTS: %d\n", ret);
 
 	mei_cldev_disable(cldev);
-	kfree(ipts);
 }
 
 static struct mei_cl_device_id ipts_mei_device_id_table[] = {
-	{ "", IPTS_MEI_UUID, MEI_CL_VERSION_ANY },
+	{ .uuid = IPTS_MEI_UUID, .version = MEI_CL_VERSION_ANY },
 	{},
 };
 MODULE_DEVICE_TABLE(mei, ipts_mei_device_id_table);
@@ -93,33 +102,8 @@ static struct mei_cl_driver ipts_mei_dri
 	.probe = ipts_mei_probe,
 	.remove = ipts_mei_remove,
 };
-
-static int __init ipts_mei_init(void)
-{
-	int ret;
-
-	ret = ipts_uapi_init();
-	if (ret)
-		return ret;
-
-	ret = mei_cldev_driver_register(&ipts_mei_driver);
-	if (ret) {
-		ipts_uapi_free();
-		return ret;
-	}
-
-	return 0;
-}
-
-static void __exit ipts_mei_exit(void)
-{
-	mei_cldev_driver_unregister(&ipts_mei_driver);
-	ipts_uapi_free();
-}
+module_mei_cl_driver(ipts_mei_driver);
 
 MODULE_DESCRIPTION("IPTS touchscreen driver");
 MODULE_AUTHOR("Dorian Stoll <dorian.stoll@tmsp.io>");
 MODULE_LICENSE("GPL");
-
-module_init(ipts_mei_init);
-module_exit(ipts_mei_exit);
diff -Npur a/drivers/misc/ipts/protocol.h b/drivers/misc/ipts/protocol.h
--- a/drivers/misc/ipts/protocol.h	2022-12-24 14:05:14.978678975 -0500
+++ b/drivers/misc/ipts/protocol.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,347 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-/*
- * Copyright (c) 2016 Intel Corporation
- * Copyright (c) 2020 Dorian Stoll
- *
- * Linux driver for Intel Precise Touch & Stylus
- */
-
-#ifndef _IPTS_PROTOCOL_H_
-#define _IPTS_PROTOCOL_H_
-
-#include <linux/types.h>
-
-/*
- * The MEI client ID for IPTS functionality.
- */
-#define IPTS_MEI_UUID                                                          \
-	UUID_LE(0x3e8d0870, 0x271a, 0x4208, 0x8e, 0xb5, 0x9a, 0xcb, 0x94,      \
-		0x02, 0xae, 0x04)
-
-/*
- * Queries the device for vendor specific information.
- *
- * The command must not contain any payload.
- * The response will contain struct ipts_get_device_info_rsp as payload.
- */
-#define IPTS_CMD_GET_DEVICE_INFO 0x00000001
-#define IPTS_RSP_GET_DEVICE_INFO 0x80000001
-
-/*
- * Sets the mode that IPTS will operate in.
- *
- * The command must contain struct ipts_set_mode_cmd as payload.
- * The response will not contain any payload.
- */
-#define IPTS_CMD_SET_MODE 0x00000002
-#define IPTS_RSP_SET_MODE 0x80000002
-
-/*
- * Configures the memory buffers that the ME will use
- * for passing data to the host.
- *
- * The command must contain struct ipts_set_mem_window_cmd as payload.
- * The response will not contain any payload.
- */
-#define IPTS_CMD_SET_MEM_WINDOW 0x00000003
-#define IPTS_RSP_SET_MEM_WINDOW 0x80000003
-
-/*
- * Signals that the host is ready to receive data to the ME.
- *
- * The command must not contain any payload.
- * The response will not contain any payload.
- */
-#define IPTS_CMD_READY_FOR_DATA 0x00000005
-#define IPTS_RSP_READY_FOR_DATA 0x80000005
-
-/*
- * Signals that a buffer can be refilled to the ME.
- *
- * The command must contain struct ipts_feedback_cmd as payload.
- * The response will not contain any payload.
- */
-#define IPTS_CMD_FEEDBACK 0x00000006
-#define IPTS_RSP_FEEDBACK 0x80000006
-
-/*
- * Resets the data flow from the ME to the hosts and
- * clears the buffers that were set with SET_MEM_WINDOW.
- *
- * The command must not contain any payload.
- * The response will not contain any payload.
- */
-#define IPTS_CMD_CLEAR_MEM_WINDOW 0x00000007
-#define IPTS_RSP_CLEAR_MEM_WINDOW 0x80000007
-
-/*
- * Instructs the ME to reset the touch sensor.
- *
- * The command must contain struct ipts_reset_sensor_cmd as payload.
- * The response will not contain any payload.
- */
-#define IPTS_CMD_RESET_SENSOR 0x0000000B
-#define IPTS_RSP_RESET_SENSOR 0x8000000B
-
-/**
- * enum ipts_status - Possible status codes returned by IPTS commands.
- * @IPTS_STATUS_SUCCESS:                 Operation completed successfully.
- * @IPTS_STATUS_INVALID_PARAMS:          Command contained a payload with invalid parameters.
- * @IPTS_STATUS_ACCESS_DENIED:           ME could not validate buffer addresses supplied by host.
- * @IPTS_STATUS_CMD_SIZE_ERROR:          Command contains an invalid payload.
- * @IPTS_STATUS_NOT_READY:               Buffer addresses have not been set.
- * @IPTS_STATUS_REQUEST_OUTSTANDING:     There is an outstanding command of the same type.
- *                                       The host must wait for a response before sending another
- *                                       command of the same type.
- * @IPTS_STATUS_NO_SENSOR_FOUND:         No sensor could be found. Either no sensor is connected, it
- *                                       has not been initialized yet, or the system is improperly
- *                                       configured.
- * @IPTS_STATUS_OUT_OF_MEMORY:           Not enough free memory for requested operation.
- * @IPTS_STATUS_INTERNAL_ERROR:          An unexpected error occurred.
- * @IPTS_STATUS_SENSOR_DISABLED:         The sensor has been disabled and must be reinitialized.
- * @IPTS_STATUS_COMPAT_CHECK_FAIL:       Compatibility revision check between sensor and ME failed.
- *                                       The host can ignore this error and attempt to continue.
- * @IPTS_STATUS_SENSOR_EXPECTED_RESET:   The sensor went through a reset initiated by ME or host.
- * @IPTS_STATUS_SENSOR_UNEXPECTED_RESET: The sensor went through an unexpected reset.
- * @IPTS_STATUS_RESET_FAILED:            Requested sensor reset failed to complete.
- * @IPTS_STATUS_TIMEOUT:                 The operation timed out.
- * @IPTS_STATUS_TEST_MODE_FAIL:          Test mode pattern did not match expected values.
- * @IPTS_STATUS_SENSOR_FAIL_FATAL:       The sensor reported a fatal error during reset sequence.
- *                                       Further progress is not possible.
- * @IPTS_STATUS_SENSOR_FAIL_NONFATAL:    The sensor reported a fatal error during reset sequence.
- *                                       The host can attempt to continue.
- * @IPTS_STATUS_INVALID_DEVICE_CAPS:     The device reported invalid capabilities.
- * @IPTS_STATUS_QUIESCE_IO_IN_PROGRESS:  Command cannot be completed until Quiesce IO is done.
- */
-enum ipts_status {
-	IPTS_STATUS_SUCCESS = 0,
-	IPTS_STATUS_INVALID_PARAMS = 1,
-	IPTS_STATUS_ACCESS_DENIED = 2,
-	IPTS_STATUS_CMD_SIZE_ERROR = 3,
-	IPTS_STATUS_NOT_READY = 4,
-	IPTS_STATUS_REQUEST_OUTSTANDING = 5,
-	IPTS_STATUS_NO_SENSOR_FOUND = 6,
-	IPTS_STATUS_OUT_OF_MEMORY = 7,
-	IPTS_STATUS_INTERNAL_ERROR = 8,
-	IPTS_STATUS_SENSOR_DISABLED = 9,
-	IPTS_STATUS_COMPAT_CHECK_FAIL = 10,
-	IPTS_STATUS_SENSOR_EXPECTED_RESET = 11,
-	IPTS_STATUS_SENSOR_UNEXPECTED_RESET = 12,
-	IPTS_STATUS_RESET_FAILED = 13,
-	IPTS_STATUS_TIMEOUT = 14,
-	IPTS_STATUS_TEST_MODE_FAIL = 15,
-	IPTS_STATUS_SENSOR_FAIL_FATAL = 16,
-	IPTS_STATUS_SENSOR_FAIL_NONFATAL = 17,
-	IPTS_STATUS_INVALID_DEVICE_CAPS = 18,
-	IPTS_STATUS_QUIESCE_IO_IN_PROGRESS = 19,
-};
-
-/*
- * The amount of buffers that is used for IPTS
- */
-#define IPTS_BUFFERS 16
-
-/*
- * The special buffer ID that is used for direct host2me feedback.
- */
-#define IPTS_HOST2ME_BUFFER IPTS_BUFFERS
-
-/**
- * enum ipts_mode - Operation mode for IPTS hardware
- * @IPTS_MODE_SINGLETOUCH: Fallback that supports only one finger and no stylus.
- *                         The data is received as a HID report with ID 64.
- * @IPTS_MODE_MULTITOUCH:  The "proper" operation mode for IPTS. It will return
- *                         stylus data as well as capacitive heatmap touch data.
- *                         This data needs to be processed in userspace.
- */
-enum ipts_mode {
-	IPTS_MODE_SINGLETOUCH = 0,
-	IPTS_MODE_MULTITOUCH = 1,
-};
-
-/**
- * struct ipts_set_mode_cmd - Payload for the SET_MODE command.
- * @mode: The mode that IPTS should operate in.
- */
-struct ipts_set_mode_cmd {
-	enum ipts_mode mode;
-	u8 reserved[12];
-} __packed;
-
-#define IPTS_WORKQUEUE_SIZE	 8192
-#define IPTS_WORKQUEUE_ITEM_SIZE 16
-
-/**
- * struct ipts_set_mem_window_cmd - Payload for the SET_MEM_WINDOW command.
- * @data_buffer_addr_lower:     Lower 32 bits of the data buffer addresses.
- * @data_buffer_addr_upper:     Upper 32 bits of the data buffer addresses.
- * @workqueue_addr_lower:       Lower 32 bits of the workqueue buffer address.
- * @workqueue_addr_upper:       Upper 32 bits of the workqueue buffer address.
- * @doorbell_addr_lower:        Lower 32 bits of the doorbell buffer address.
- * @doorbell_addr_upper:        Upper 32 bits of the doorbell buffer address.
- * @feedback_buffer_addr_lower: Lower 32 bits of the feedback buffer addresses.
- * @feedback_buffer_addr_upper: Upper 32 bits of the feedback buffer addresses.
- * @host2me_addr_lower:         Lower 32 bits of the host2me buffer address.
- * @host2me_addr_upper:         Upper 32 bits of the host2me buffer address.
- * @workqueue_item_size:        Magic value. (IPTS_WORKQUEUE_ITEM_SIZE)
- * @workqueue_size:             Magic value. (IPTS_WORKQUEUE_SIZE)
- *
- * The data buffers are buffers that get filled with touch data by the ME.
- * The doorbell buffer is a u32 that gets incremented by the ME once a data
- * buffer has been filled with new data.
- *
- * The other buffers are required for using GuC submission with binary
- * firmware. Since support for GuC submission has been dropped from i915,
- * they are not used anymore, but they need to be allocated and passed,
- * otherwise the hardware will refuse to start.
- */
-struct ipts_set_mem_window_cmd {
-	u32 data_buffer_addr_lower[IPTS_BUFFERS];
-	u32 data_buffer_addr_upper[IPTS_BUFFERS];
-	u32 workqueue_addr_lower;
-	u32 workqueue_addr_upper;
-	u32 doorbell_addr_lower;
-	u32 doorbell_addr_upper;
-	u32 feedback_buffer_addr_lower[IPTS_BUFFERS];
-	u32 feedback_buffer_addr_upper[IPTS_BUFFERS];
-	u32 host2me_addr_lower;
-	u32 host2me_addr_upper;
-	u32 host2me_size;
-	u8 reserved1;
-	u8 workqueue_item_size;
-	u16 workqueue_size;
-	u8 reserved[32];
-} __packed;
-
-/**
- * struct ipts_feedback_cmd - Payload for the FEEDBACK command.
- * @buffer: The buffer that the ME should refill.
- */
-struct ipts_feedback_cmd {
-	u32 buffer;
-	u8 reserved[12];
-} __packed;
-
-/**
- * enum ipts_feedback_cmd_type - Commands that can be executed on the sensor through feedback.
- */
-enum ipts_feedback_cmd_type {
-	IPTS_FEEDBACK_CMD_TYPE_NONE = 0,
-	IPTS_FEEDBACK_CMD_TYPE_SOFT_RESET = 1,
-	IPTS_FEEDBACK_CMD_TYPE_GOTO_ARMED = 2,
-	IPTS_FEEDBACK_CMD_TYPE_GOTO_SENSING = 3,
-	IPTS_FEEDBACK_CMD_TYPE_GOTO_SLEEP = 4,
-	IPTS_FEEDBACK_CMD_TYPE_GOTO_DOZE = 5,
-	IPTS_FEEDBACK_CMD_TYPE_HARD_RESET = 6,
-};
-
-/**
- * enum ipts_feedback_data_type - Describes the data that a feedback buffer contains.
- * @IPTS_FEEDBACK_DATA_TYPE_VENDOR:        The buffer contains vendor specific feedback.
- * @IPTS_FEEDBACK_DATA_TYPE_SET_FEATURES:  The buffer contains a HID set features command.
- * @IPTS_FEEDBACK_DATA_TYPE_GET_FEATURES:  The buffer contains a HID get features command.
- * @IPTS_FEEDBACK_DATA_TYPE_OUTPUT_REPORT: The buffer contains a HID output report.
- * @IPTS_FEEDBACK_DATA_TYPE_STORE_DATA:    The buffer contains calibration data for the sensor.
- */
-enum ipts_feedback_data_type {
-	IPTS_FEEDBACK_DATA_TYPE_VENDOR = 0,
-	IPTS_FEEDBACK_DATA_TYPE_SET_FEATURES = 1,
-	IPTS_FEEDBACK_DATA_TYPE_GET_FEATURES = 2,
-	IPTS_FEEDBACK_DATA_TYPE_OUTPUT_REPORT = 3,
-	IPTS_FEEDBACK_DATA_TYPE_STORE_DATA = 4,
-};
-
-/**
- * struct ipts_feedback_buffer - The contents of an IPTS feedback buffer.
- * @cmd_type: A command that should be executed on the sensor.
- * @size: The size of the payload to be written.
- * @buffer: The ID of the buffer that contains this feedback data.
- * @protocol: The protocol version of the EDS.
- * @data_type: The type of payload that the buffer contains.
- * @spi_offset: The offset at which to write the payload data.
- * @payload: Payload for the feedback command, or 0 if no payload is sent.
- */
-struct ipts_feedback_buffer {
-	enum ipts_feedback_cmd_type cmd_type;
-	u32 size;
-	u32 buffer;
-	u32 protocol;
-	enum ipts_feedback_data_type data_type;
-	u32 spi_offset;
-	u8 reserved[40];
-	u8 payload[];
-} __packed;
-
-/**
- * enum ipts_reset_type - Possible ways of resetting the touch sensor
- * @IPTS_RESET_TYPE_HARD: Perform hardware reset using GPIO pin.
- * @IPTS_RESET_TYPE_SOFT: Perform software reset using SPI interface.
- */
-enum ipts_reset_type {
-	IPTS_RESET_TYPE_HARD = 0,
-	IPTS_RESET_TYPE_SOFT = 1,
-};
-
-/**
- * struct ipts_reset_sensor_cmd - Payload for the RESET_SENSOR command.
- * @type: What type of reset should be performed.
- */
-struct ipts_reset_sensor_cmd {
-	enum ipts_reset_type type;
-	u8 reserved[4];
-} __packed;
-
-/**
- * struct ipts_command - A message sent from the host to the ME.
- * @code:    The message code describing the command. (see IPTS_CMD_*)
- * @payload: Payload for the command, or 0 if no payload is required.
- */
-struct ipts_command {
-	u32 code;
-	u8 payload[320];
-} __packed;
-
-/**
- * struct ipts_device_info - Payload for the GET_DEVICE_INFO response.
- * @vendor_id:     Vendor ID of the touch sensor.
- * @device_id:     Device ID of the touch sensor.
- * @hw_rev:        Hardware revision of the touch sensor.
- * @fw_rev:        Firmware revision of the touch sensor.
- * @data_size:     Required size of one data buffer.
- * @feedback_size: Required size of one feedback buffer.
- * @mode:          Current operation mode of IPTS.
- * @max_contacts:  The amount of concurrent touches supported by the sensor.
- */
-struct ipts_get_device_info_rsp {
-	u16 vendor_id;
-	u16 device_id;
-	u32 hw_rev;
-	u32 fw_rev;
-	u32 data_size;
-	u32 feedback_size;
-	enum ipts_mode mode;
-	u8 max_contacts;
-	u8 reserved[19];
-} __packed;
-
-/**
- * struct ipts_feedback_rsp - Payload for the FEEDBACK response.
- * @buffer: The buffer that has received feedback.
- */
-struct ipts_feedback_rsp {
-	u32 buffer;
-} __packed;
-
-/**
- * struct ipts_response - A message sent from the ME to the host.
- * @code:    The message code describing the response. (see IPTS_RSP_*)
- * @status:  The status code returned by the command.
- * @payload: Payload returned by the command.
- */
-struct ipts_response {
-	u32 code;
-	enum ipts_status status;
-	u8 payload[80];
-} __packed;
-
-#endif /* _IPTS_PROTOCOL_H_ */
diff -Npur a/drivers/misc/ipts/receiver.c b/drivers/misc/ipts/receiver.c
--- a/drivers/misc/ipts/receiver.c	2022-12-24 14:05:14.978678975 -0500
+++ b/drivers/misc/ipts/receiver.c	2022-12-11 15:54:14.000000000 -0500
@@ -1,224 +1,208 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) 2016 Intel Corporation
- * Copyright (c) 2020 Dorian Stoll
+ * Copyright (c) 2020-2022 Dorian Stoll
  *
  * Linux driver for Intel Precise Touch & Stylus
  */
 
-#include <linux/mei_cl_bus.h>
-#include <linux/moduleparam.h>
+#include <linux/delay.h>
+#include <linux/kthread.h>
+#include <linux/time64.h>
+#include <linux/timekeeping.h>
 #include <linux/types.h>
 
+#include "cmd.h"
 #include "context.h"
 #include "control.h"
-#include "protocol.h"
+#include "hid.h"
 #include "resources.h"
+#include "spec-device.h"
 
-/*
- * Temporary parameter to guard gen7 multitouch mode.
- * Remove once gen7 has stable iptsd support.
- */
-static bool gen7mt;
-module_param(gen7mt, bool, 0644);
-
-static int ipts_receiver_handle_get_device_info(struct ipts_context *ipts,
-						struct ipts_response *rsp)
+static void ipts_receiver_next_doorbell(struct ipts_context *ipts)
 {
-	struct ipts_set_mode_cmd cmd;
-
-	memcpy(&ipts->device_info, rsp->payload,
-	       sizeof(struct ipts_get_device_info_rsp));
+	u32 *doorbell = (u32 *)ipts->resources.doorbell.address;
+	*doorbell = *doorbell + 1;
+}
 
-	memset(&cmd, 0, sizeof(struct ipts_set_mode_cmd));
-	cmd.mode = IPTS_MODE_MULTITOUCH;
+static u32 ipts_receiver_current_doorbell(struct ipts_context *ipts)
+{
+	u32 *doorbell = (u32 *)ipts->resources.doorbell.address;
+	return *doorbell;
+}
 
-	return ipts_control_send(ipts, IPTS_CMD_SET_MODE, &cmd,
-				 sizeof(struct ipts_set_mode_cmd));
+static void ipts_receiver_backoff(time64_t last, u32 n)
+{
+	/*
+	 * If the last change was less than n seconds ago,
+	 * sleep for a shorter period so that new data can be
+	 * processed quickly. If there was no change for more than
+	 * n seconds, sleep longer to avoid wasting CPU cycles.
+	 */
+	if (last + n > ktime_get_seconds())
+		msleep(20);
+	else
+		msleep(200);
 }
 
-static int ipts_receiver_handle_set_mode(struct ipts_context *ipts)
+static int ipts_receiver_event_loop(void *data)
 {
-	int i, ret;
-	struct ipts_set_mem_window_cmd cmd;
+	int ret;
+	u32 buffer;
 
-	ret = ipts_resources_alloc(ipts);
-	if (ret) {
-		dev_err(ipts->dev, "Failed to allocate resources\n");
-		return ret;
-	}
+	struct ipts_context *ipts = data;
+	time64_t last = ktime_get_seconds();
 
-	memset(&cmd, 0, sizeof(struct ipts_set_mem_window_cmd));
+	if (!ipts)
+		return -EFAULT;
 
-	for (i = 0; i < IPTS_BUFFERS; i++) {
-		cmd.data_buffer_addr_lower[i] =
-			lower_32_bits(ipts->data[i].dma_address);
+	dev_info(ipts->dev, "IPTS running in event mode\n");
 
-		cmd.data_buffer_addr_upper[i] =
-			upper_32_bits(ipts->data[i].dma_address);
+	while (!kthread_should_stop()) {
+		for (int i = 0; i < IPTS_BUFFERS; i++) {
+			ret = ipts_control_wait_data(ipts, false);
+			if (ret == -EAGAIN)
+				break;
 
-		cmd.feedback_buffer_addr_lower[i] =
-			lower_32_bits(ipts->feedback[i].dma_address);
+			if (ret) {
+				dev_err(ipts->dev, "Failed to wait for data: %d\n", ret);
+				continue;
+			}
 
-		cmd.feedback_buffer_addr_upper[i] =
-			upper_32_bits(ipts->feedback[i].dma_address);
-	}
+			buffer = ipts_receiver_current_doorbell(ipts) % IPTS_BUFFERS;
+			ipts_receiver_next_doorbell(ipts);
 
-	cmd.workqueue_addr_lower = lower_32_bits(ipts->workqueue.dma_address);
-	cmd.workqueue_addr_upper = upper_32_bits(ipts->workqueue.dma_address);
+			ret = ipts_hid_input_data(ipts, buffer);
+			if (ret)
+				dev_err(ipts->dev, "Failed to process buffer: %d\n", ret);
 
-	cmd.doorbell_addr_lower = lower_32_bits(ipts->doorbell.dma_address);
-	cmd.doorbell_addr_upper = upper_32_bits(ipts->doorbell.dma_address);
+			ret = ipts_control_refill_buffer(ipts, buffer);
+			if (ret)
+				dev_err(ipts->dev, "Failed to send feedback: %d\n", ret);
 
-	cmd.host2me_addr_lower = lower_32_bits(ipts->host2me.dma_address);
-	cmd.host2me_addr_upper = upper_32_bits(ipts->host2me.dma_address);
+			ret = ipts_control_request_data(ipts);
+			if (ret)
+				dev_err(ipts->dev, "Failed to request data: %d\n", ret);
 
-	cmd.workqueue_size = IPTS_WORKQUEUE_SIZE;
-	cmd.workqueue_item_size = IPTS_WORKQUEUE_ITEM_SIZE;
+			last = ktime_get_seconds();
+		}
 
-	return ipts_control_send(ipts, IPTS_CMD_SET_MEM_WINDOW, &cmd,
-				 sizeof(struct ipts_set_mem_window_cmd));
-}
-
-static int ipts_receiver_handle_set_mem_window(struct ipts_context *ipts)
-{
-	int ret;
+		ipts_receiver_backoff(last, 5);
+	}
 
-	dev_info(ipts->dev, "Device %04hX:%04hX ready\n",
-		 ipts->device_info.vendor_id, ipts->device_info.device_id);
-	ipts->status = IPTS_HOST_STATUS_STARTED;
+	ret = ipts_control_request_flush(ipts);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to request flush: %d\n", ret);
+		return ret;
+	}
 
-	ret = ipts_control_send(ipts, IPTS_CMD_READY_FOR_DATA, NULL, 0);
-	if (ret)
+	ret = ipts_control_wait_data(ipts, true);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to wait for data: %d\n", ret);
 		return ret;
+	}
 
-	if (!gen7mt)
-		return 0;
+	ret = ipts_control_wait_flush(ipts);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to wait for flush: %d\n", ret);
+		return ret;
+	}
 
-	return ipts_control_set_feature(ipts, 0x5, 0x1);
+	return 0;
 }
 
-static int ipts_receiver_handle_feedback(struct ipts_context *ipts,
-					 struct ipts_response *rsp)
+static int ipts_receiver_doorbell_loop(void *data)
 {
-	struct ipts_feedback_rsp feedback;
+	int ret;
+	u32 buffer;
 
-	if (ipts->status != IPTS_HOST_STATUS_STOPPING)
-		return 0;
+	u32 doorbell = 0;
+	u32 lastdb = 0;
 
-	memcpy(&feedback, rsp->payload, sizeof(feedback));
+	struct ipts_context *ipts = data;
+	time64_t last = ktime_get_seconds();
 
-	if (feedback.buffer < IPTS_BUFFERS - 1)
-		return ipts_control_send_feedback(ipts, feedback.buffer + 1);
+	if (!ipts)
+		return -EFAULT;
 
-	return ipts_control_send(ipts, IPTS_CMD_CLEAR_MEM_WINDOW, NULL, 0);
-}
+	dev_info(ipts->dev, "IPTS running in doorbell mode\n");
 
-static int ipts_receiver_handle_clear_mem_window(struct ipts_context *ipts)
-{
-	ipts->status = IPTS_HOST_STATUS_STOPPED;
+	while (true) {
+		if (kthread_should_stop()) {
+			ret = ipts_control_request_flush(ipts);
+			if (ret) {
+				dev_err(ipts->dev, "Failed to request flush: %d\n", ret);
+				return ret;
+			}
+		}
 
-	if (ipts->restart)
-		return ipts_control_start(ipts);
+		doorbell = ipts_receiver_current_doorbell(ipts);
 
-	return 0;
-}
+		/*
+		 * After filling up one of the data buffers, IPTS will increment
+		 * the doorbell. The value of the doorbell stands for the *next*
+		 * buffer that IPTS is going to fill.
+		 */
+		while (lastdb != doorbell) {
+			buffer = lastdb % IPTS_BUFFERS;
 
-static bool ipts_receiver_sensor_was_reset(u32 status)
-{
-	return status == IPTS_STATUS_SENSOR_EXPECTED_RESET ||
-	       status == IPTS_STATUS_SENSOR_UNEXPECTED_RESET;
-}
+			ret = ipts_hid_input_data(ipts, buffer);
+			if (ret)
+				dev_err(ipts->dev, "Failed to process buffer: %d\n", ret);
 
-static bool ipts_receiver_handle_error(struct ipts_context *ipts,
-				       struct ipts_response *rsp)
-{
-	bool error;
+			ret = ipts_control_refill_buffer(ipts, buffer);
+			if (ret)
+				dev_err(ipts->dev, "Failed to send feedback: %d\n", ret);
 
-	switch (rsp->status) {
-	case IPTS_STATUS_SUCCESS:
-	case IPTS_STATUS_COMPAT_CHECK_FAIL:
-		error = false;
-		break;
-	case IPTS_STATUS_INVALID_PARAMS:
-		error = rsp->code != IPTS_RSP_FEEDBACK;
-		break;
-	case IPTS_STATUS_SENSOR_DISABLED:
-		error = ipts->status != IPTS_HOST_STATUS_STOPPING;
-		break;
-	default:
-		error = true;
-		break;
-	}
+			last = ktime_get_seconds();
+			lastdb++;
+		}
 
-	if (!error)
-		return false;
+		if (kthread_should_stop())
+			break;
 
-	dev_err(ipts->dev, "Command 0x%08x failed: %d\n", rsp->code,
-		rsp->status);
+		ipts_receiver_backoff(last, 5);
+	}
 
-	if (ipts_receiver_sensor_was_reset(rsp->status)) {
-		dev_err(ipts->dev, "Sensor was reset\n");
+	ret = ipts_control_wait_data(ipts, true);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to wait for data: %d\n", ret);
+		return ret;
+	}
 
-		if (ipts_control_restart(ipts))
-			dev_err(ipts->dev, "Failed to restart IPTS\n");
+	ret = ipts_control_wait_flush(ipts);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to wait for flush: %d\n", ret);
+		return ret;
 	}
 
-	return true;
+	return 0;
 }
 
-static void ipts_receiver_handle_response(struct ipts_context *ipts,
-					  struct ipts_response *rsp)
+void ipts_receiver_start(struct ipts_context *ipts)
 {
-	int ret;
-
-	if (ipts_receiver_handle_error(ipts, rsp))
+	if (!ipts)
 		return;
 
-	switch (rsp->code) {
-	case IPTS_RSP_GET_DEVICE_INFO:
-		ret = ipts_receiver_handle_get_device_info(ipts, rsp);
-		break;
-	case IPTS_RSP_SET_MODE:
-		ret = ipts_receiver_handle_set_mode(ipts);
-		break;
-	case IPTS_RSP_SET_MEM_WINDOW:
-		ret = ipts_receiver_handle_set_mem_window(ipts);
-		break;
-	case IPTS_RSP_FEEDBACK:
-		ret = ipts_receiver_handle_feedback(ipts, rsp);
-		break;
-	case IPTS_RSP_CLEAR_MEM_WINDOW:
-		ret = ipts_receiver_handle_clear_mem_window(ipts);
-		break;
-	default:
-		ret = 0;
-		break;
-	}
-
-	if (!ret)
-		return;
+	if (ipts->mode == IPTS_MODE_EVENT)
+		ipts->event_loop = kthread_run(ipts_receiver_event_loop, ipts, "ipts_event");
 
-	dev_err(ipts->dev, "Error while handling response 0x%08x: %d\n",
-		rsp->code, ret);
-
-	if (ipts_control_stop(ipts))
-		dev_err(ipts->dev, "Failed to stop IPTS\n");
+	if (ipts->mode == IPTS_MODE_DOORBELL)
+		ipts->doorbell_loop = kthread_run(ipts_receiver_doorbell_loop, ipts, "ipts_db");
 }
 
-void ipts_receiver_callback(struct mei_cl_device *cldev)
+void ipts_receiver_stop(struct ipts_context *ipts)
 {
-	int ret;
-	struct ipts_response rsp;
-	struct ipts_context *ipts;
-
-	ipts = mei_cldev_get_drvdata(cldev);
-
-	ret = mei_cldev_recv(cldev, (u8 *)&rsp, sizeof(struct ipts_response));
-	if (ret <= 0) {
-		dev_err(ipts->dev, "Error while reading response: %d\n", ret);
+	if (!ipts)
 		return;
+
+	if (ipts->event_loop) {
+		kthread_stop(ipts->event_loop);
+		ipts->event_loop = NULL;
 	}
 
-	ipts_receiver_handle_response(ipts, &rsp);
+	if (ipts->doorbell_loop) {
+		kthread_stop(ipts->doorbell_loop);
+		ipts->doorbell_loop = NULL;
+	}
 }
diff -Npur a/drivers/misc/ipts/receiver.h b/drivers/misc/ipts/receiver.h
--- a/drivers/misc/ipts/receiver.h	2022-12-24 14:05:14.978678975 -0500
+++ b/drivers/misc/ipts/receiver.h	2022-12-11 15:54:14.000000000 -0500
@@ -1,16 +1,17 @@
 /* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * Copyright (c) 2016 Intel Corporation
- * Copyright (c) 2020 Dorian Stoll
+ * Copyright (c) 2020-2022 Dorian Stoll
  *
  * Linux driver for Intel Precise Touch & Stylus
  */
 
-#ifndef _IPTS_RECEIVER_H_
-#define _IPTS_RECEIVER_H_
+#ifndef IPTS_RECEIVER_H
+#define IPTS_RECEIVER_H
 
-#include <linux/mei_cl_bus.h>
+#include "context.h"
 
-void ipts_receiver_callback(struct mei_cl_device *cldev);
+void ipts_receiver_start(struct ipts_context *ipts);
+void ipts_receiver_stop(struct ipts_context *ipts);
 
-#endif /* _IPTS_RECEIVER_H_ */
+#endif /* IPTS_RECEIVER_H */
diff -Npur a/drivers/misc/ipts/resources.c b/drivers/misc/ipts/resources.c
--- a/drivers/misc/ipts/resources.c	2022-12-24 14:05:14.978678975 -0500
+++ b/drivers/misc/ipts/resources.c	2022-12-11 15:54:14.000000000 -0500
@@ -1,128 +1,106 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (c) 2016 Intel Corporation
- * Copyright (c) 2020 Dorian Stoll
+ * Copyright (c) 2020-2022 Dorian Stoll
  *
  * Linux driver for Intel Precise Touch & Stylus
  */
 
 #include <linux/dma-mapping.h>
+#include <linux/types.h>
 
-#include "context.h"
+#include "resources.h"
+#include "spec-device.h"
 
-void ipts_resources_free(struct ipts_context *ipts)
+static int ipts_resources_alloc_buffer(struct ipts_buffer *buffer, struct device *dev, size_t size)
 {
-	int i;
-	struct ipts_buffer_info *buffers;
+	if (!buffer)
+		return -EFAULT;
 
-	u32 data_buffer_size = ipts->device_info.data_size;
-	u32 feedback_buffer_size = ipts->device_info.feedback_size;
+	if (buffer->address)
+		return 0;
 
-	buffers = ipts->data;
-	for (i = 0; i < IPTS_BUFFERS; i++) {
-		if (!buffers[i].address)
-			continue;
+	buffer->address = dma_alloc_coherent(dev, size, &buffer->dma_address, GFP_KERNEL);
 
-		dma_free_coherent(ipts->dev, data_buffer_size,
-				  buffers[i].address, buffers[i].dma_address);
+	if (!buffer->address)
+		return -ENOMEM;
 
-		buffers[i].address = NULL;
-		buffers[i].dma_address = 0;
-	}
+	buffer->size = size;
+	buffer->device = dev;
 
-	buffers = ipts->feedback;
-	for (i = 0; i < IPTS_BUFFERS; i++) {
-		if (!buffers[i].address)
-			continue;
+	return 0;
+}
 
-		dma_free_coherent(ipts->dev, feedback_buffer_size,
-				  buffers[i].address, buffers[i].dma_address);
+static void ipts_resources_free_buffer(struct ipts_buffer *buffer)
+{
+	if (!buffer || !buffer->address)
+		return;
 
-		buffers[i].address = NULL;
-		buffers[i].dma_address = 0;
-	}
+	dma_free_coherent(buffer->device, buffer->size, buffer->address, buffer->dma_address);
 
-	if (ipts->doorbell.address) {
-		dma_free_coherent(ipts->dev, sizeof(u32),
-				  ipts->doorbell.address,
-				  ipts->doorbell.dma_address);
+	buffer->address = NULL;
+	buffer->size = 0;
 
-		ipts->doorbell.address = NULL;
-		ipts->doorbell.dma_address = 0;
-	}
+	buffer->dma_address = 0;
+	buffer->device = NULL;
+}
 
-	if (ipts->workqueue.address) {
-		dma_free_coherent(ipts->dev, sizeof(u32),
-				  ipts->workqueue.address,
-				  ipts->workqueue.dma_address);
+int ipts_resources_init(struct ipts_resources *res, struct device *dev, size_t ds, size_t fs)
+{
+	int ret;
 
-		ipts->workqueue.address = NULL;
-		ipts->workqueue.dma_address = 0;
-	}
+	if (!res)
+		return -EFAULT;
 
-	if (ipts->host2me.address) {
-		dma_free_coherent(ipts->dev, feedback_buffer_size,
-				  ipts->host2me.address,
-				  ipts->host2me.dma_address);
+	for (int i = 0; i < IPTS_BUFFERS; i++) {
+		ret = ipts_resources_alloc_buffer(&res->data[i], dev, ds);
+		if (ret)
+			goto err;
+	}
 
-		ipts->host2me.address = NULL;
-		ipts->host2me.dma_address = 0;
+	for (int i = 0; i < IPTS_BUFFERS; i++) {
+		ret = ipts_resources_alloc_buffer(&res->feedback[i], dev, fs);
+		if (ret)
+			goto err;
 	}
-}
 
-int ipts_resources_alloc(struct ipts_context *ipts)
-{
-	int i;
-	struct ipts_buffer_info *buffers;
+	ret = ipts_resources_alloc_buffer(&res->doorbell, dev, sizeof(u32));
+	if (ret)
+		goto err;
 
-	u32 data_buffer_size = ipts->device_info.data_size;
-	u32 feedback_buffer_size = ipts->device_info.feedback_size;
+	ret = ipts_resources_alloc_buffer(&res->workqueue, dev, sizeof(u32));
+	if (ret)
+		goto err;
 
-	buffers = ipts->data;
-	for (i = 0; i < IPTS_BUFFERS; i++) {
-		buffers[i].address =
-			dma_alloc_coherent(ipts->dev, data_buffer_size,
-					   &buffers[i].dma_address, GFP_KERNEL);
+	ret = ipts_resources_alloc_buffer(&res->hid2me, dev, fs);
+	if (ret)
+		goto err;
 
-		if (!buffers[i].address)
-			goto release_resources;
-	}
+	ret = ipts_resources_alloc_buffer(&res->descriptor, dev, ds + 8);
+	if (ret)
+		goto err;
 
-	buffers = ipts->feedback;
-	for (i = 0; i < IPTS_BUFFERS; i++) {
-		buffers[i].address =
-			dma_alloc_coherent(ipts->dev, feedback_buffer_size,
-					   &buffers[i].dma_address, GFP_KERNEL);
+	return 0;
 
-		if (!buffers[i].address)
-			goto release_resources;
-	}
+err:
 
-	ipts->doorbell.address =
-		dma_alloc_coherent(ipts->dev, sizeof(u32),
-				   &ipts->doorbell.dma_address, GFP_KERNEL);
-
-	if (!ipts->doorbell.address)
-		goto release_resources;
-
-	ipts->workqueue.address =
-		dma_alloc_coherent(ipts->dev, sizeof(u32),
-				   &ipts->workqueue.dma_address, GFP_KERNEL);
-
-	if (!ipts->workqueue.address)
-		goto release_resources;
-
-	ipts->host2me.address =
-		dma_alloc_coherent(ipts->dev, feedback_buffer_size,
-				   &ipts->host2me.dma_address, GFP_KERNEL);
+	ipts_resources_free(res);
+	return ret;
+}
 
-	if (!ipts->workqueue.address)
-		goto release_resources;
+void ipts_resources_free(struct ipts_resources *res)
+{
+	if (!res)
+		return;
 
-	return 0;
+	for (int i = 0; i < IPTS_BUFFERS; i++)
+		ipts_resources_free_buffer(&res->data[i]);
 
-release_resources:
+	for (int i = 0; i < IPTS_BUFFERS; i++)
+		ipts_resources_free_buffer(&res->feedback[i]);
 
-	ipts_resources_free(ipts);
-	return -ENOMEM;
+	ipts_resources_free_buffer(&res->doorbell);
+	ipts_resources_free_buffer(&res->workqueue);
+	ipts_resources_free_buffer(&res->hid2me);
+	ipts_resources_free_buffer(&res->descriptor);
 }
diff -Npur a/drivers/misc/ipts/resources.h b/drivers/misc/ipts/resources.h
--- a/drivers/misc/ipts/resources.h	2022-12-24 14:05:14.978678975 -0500
+++ b/drivers/misc/ipts/resources.h	2022-12-11 15:54:14.000000000 -0500
@@ -1,17 +1,39 @@
 /* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * Copyright (c) 2016 Intel Corporation
- * Copyright (c) 2020 Dorian Stoll
+ * Copyright (c) 2020-2022 Dorian Stoll
  *
  * Linux driver for Intel Precise Touch & Stylus
  */
 
-#ifndef _IPTS_RESOURCES_H_
-#define _IPTS_RESOURCES_H_
+#ifndef IPTS_RESOURCES_H
+#define IPTS_RESOURCES_H
 
-#include "context.h"
+#include <linux/device.h>
+#include <linux/types.h>
 
-int ipts_resources_alloc(struct ipts_context *ipts);
-void ipts_resources_free(struct ipts_context *ipts);
+#include "spec-device.h"
 
-#endif /* _IPTS_RESOURCES_H_ */
+struct ipts_buffer {
+	u8 *address;
+	size_t size;
+
+	dma_addr_t dma_address;
+	struct device *device;
+};
+
+struct ipts_resources {
+	struct ipts_buffer data[IPTS_BUFFERS];
+	struct ipts_buffer feedback[IPTS_BUFFERS];
+
+	struct ipts_buffer doorbell;
+	struct ipts_buffer workqueue;
+	struct ipts_buffer hid2me;
+
+	struct ipts_buffer descriptor;
+};
+
+int ipts_resources_init(struct ipts_resources *res, struct device *dev, size_t ds, size_t fs);
+void ipts_resources_free(struct ipts_resources *res);
+
+#endif /* IPTS_RESOURCES_H */
diff -Npur a/drivers/misc/ipts/spec-data.h b/drivers/misc/ipts/spec-data.h
--- a/drivers/misc/ipts/spec-data.h	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/misc/ipts/spec-data.h	2022-12-11 15:54:14.000000000 -0500
@@ -0,0 +1,100 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020-2022 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#ifndef IPTS_SPEC_DATA_H
+#define IPTS_SPEC_DATA_H
+
+#include <linux/build_bug.h>
+#include <linux/types.h>
+
+/**
+ * enum ipts_feedback_cmd_type - Commands that can be executed on the sensor through feedback.
+ */
+enum ipts_feedback_cmd_type {
+	IPTS_FEEDBACK_CMD_TYPE_NONE = 0,
+	IPTS_FEEDBACK_CMD_TYPE_SOFT_RESET = 1,
+	IPTS_FEEDBACK_CMD_TYPE_GOTO_ARMED = 2,
+	IPTS_FEEDBACK_CMD_TYPE_GOTO_SENSING = 3,
+	IPTS_FEEDBACK_CMD_TYPE_GOTO_SLEEP = 4,
+	IPTS_FEEDBACK_CMD_TYPE_GOTO_DOZE = 5,
+	IPTS_FEEDBACK_CMD_TYPE_HARD_RESET = 6,
+};
+
+/**
+ * enum ipts_feedback_data_type - Defines what data a feedback buffer contains.
+ * @IPTS_FEEDBACK_DATA_TYPE_VENDOR:        The buffer contains vendor specific feedback.
+ * @IPTS_FEEDBACK_DATA_TYPE_SET_FEATURES:  The buffer contains a HID set features report.
+ * @IPTS_FEEDBACK_DATA_TYPE_GET_FEATURES:  The buffer contains a HID get features report.
+ * @IPTS_FEEDBACK_DATA_TYPE_OUTPUT_REPORT: The buffer contains a HID output report.
+ * @IPTS_FEEDBACK_DATA_TYPE_STORE_DATA:    The buffer contains calibration data for the sensor.
+ */
+enum ipts_feedback_data_type {
+	IPTS_FEEDBACK_DATA_TYPE_VENDOR = 0,
+	IPTS_FEEDBACK_DATA_TYPE_SET_FEATURES = 1,
+	IPTS_FEEDBACK_DATA_TYPE_GET_FEATURES = 2,
+	IPTS_FEEDBACK_DATA_TYPE_OUTPUT_REPORT = 3,
+	IPTS_FEEDBACK_DATA_TYPE_STORE_DATA = 4,
+};
+
+/**
+ * struct ipts_feedback_header - Header that is prefixed to the data in a feedback buffer.
+ * @cmd_type:   A command that should be executed on the sensor.
+ * @size:       The size of the payload to be written.
+ * @buffer:     The ID of the buffer that contains this feedback data.
+ * @protocol:   The protocol version of the EDS.
+ * @data_type:  The type of data that the buffer contains.
+ * @spi_offset: The offset at which to write the payload data to the sensor.
+ * @payload:    Payload for the feedback command, or 0 if no payload is sent.
+ */
+struct ipts_feedback_header {
+	enum ipts_feedback_cmd_type cmd_type;
+	u32 size;
+	u32 buffer;
+	u32 protocol;
+	enum ipts_feedback_data_type data_type;
+	u32 spi_offset;
+	u8 reserved[40];
+	u8 payload[];
+} __packed;
+
+static_assert(sizeof(struct ipts_feedback_header) == 64);
+
+/**
+ * enum ipts_data_type - Defines what type of data a buffer contains.
+ * @IPTS_DATA_TYPE_FRAME:        Raw data frame.
+ * @IPTS_DATA_TYPE_ERROR:        Error data.
+ * @IPTS_DATA_TYPE_VENDOR:       Vendor specific data.
+ * @IPTS_DATA_TYPE_HID:          A HID report.
+ * @IPTS_DATA_TYPE_GET_FEATURES: The response to a GET_FEATURES HID2ME command.
+ */
+enum ipts_data_type {
+	IPTS_DATA_TYPE_FRAME = 0x00,
+	IPTS_DATA_TYPE_ERROR = 0x01,
+	IPTS_DATA_TYPE_VENDOR = 0x02,
+	IPTS_DATA_TYPE_HID = 0x03,
+	IPTS_DATA_TYPE_GET_FEATURES = 0x04,
+	IPTS_DATA_TYPE_DESCRIPTOR = 0x05,
+};
+
+/**
+ * struct ipts_data_header - Header that is prefixed to the data in a data buffer.
+ * @type: What data the buffer contains.
+ * @size: How much data the buffer contains.
+ * @buffer: Which buffer the data is in.
+ */
+struct ipts_data_header {
+	enum ipts_data_type type;
+	u32 size;
+	u32 buffer;
+	u8 reserved[52];
+	u8 data[];
+} __packed;
+
+static_assert(sizeof(struct ipts_data_header) == 64);
+
+#endif /* IPTS_SPEC_DATA_H */
diff -Npur a/drivers/misc/ipts/spec-device.h b/drivers/misc/ipts/spec-device.h
--- a/drivers/misc/ipts/spec-device.h	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/misc/ipts/spec-device.h	2022-12-11 15:54:14.000000000 -0500
@@ -0,0 +1,285 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020-2022 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#ifndef IPTS_SPEC_DEVICE_H
+#define IPTS_SPEC_DEVICE_H
+
+#include <linux/build_bug.h>
+#include <linux/types.h>
+
+/*
+ * The amount of buffers that IPTS can use for data transfer.
+ */
+#define IPTS_BUFFERS 16
+
+/*
+ * The buffer ID that is used for HID2ME feedback
+ */
+#define IPTS_HID2ME_BUFFER IPTS_BUFFERS
+
+/**
+ * enum ipts_command - Commands that can be sent to the IPTS hardware.
+ * @IPTS_CMD_GET_DEVICE_INFO:  Retrieves vendor information from the device.
+ * @IPTS_CMD_SET_MODE:         Changes the mode that the device will operate in.
+ * @IPTS_CMD_SET_MEM_WINDOW:   Configures memory buffers for passing data between device and driver.
+ * @IPTS_CMD_QUIESCE_IO:       Stops the data flow from the device to the driver.
+ * @IPTS_CMD_READY_FOR_DATA:   Informs the device that the driver is ready to receive data.
+ * @IPTS_CMD_FEEDBACK:         Informs the device that a buffer was processed and can be refilled.
+ * @IPTS_CMD_CLEAR_MEM_WINDOW: Stops the data flow and clears the buffer addresses on the device.
+ * @IPTS_CMD_RESET_SENSOR:     Resets the sensor to its default state.
+ * @IPTS_CMD_GET_DESCRIPTOR:   Retrieves the HID descriptor of the device.
+ */
+enum ipts_command_code {
+	IPTS_CMD_GET_DEVICE_INFO = 0x01,
+	IPTS_CMD_SET_MODE = 0x02,
+	IPTS_CMD_SET_MEM_WINDOW = 0x03,
+	IPTS_CMD_QUIESCE_IO = 0x04,
+	IPTS_CMD_READY_FOR_DATA = 0x05,
+	IPTS_CMD_FEEDBACK = 0x06,
+	IPTS_CMD_CLEAR_MEM_WINDOW = 0x07,
+	IPTS_CMD_RESET_SENSOR = 0x0B,
+	IPTS_CMD_GET_DESCRIPTOR = 0x0F,
+};
+
+/**
+ * enum ipts_status - Possible status codes returned by the IPTS device.
+ * @IPTS_STATUS_SUCCESS:                 Operation completed successfully.
+ * @IPTS_STATUS_INVALID_PARAMS:          Command contained an invalid payload.
+ * @IPTS_STATUS_ACCESS_DENIED:           ME could not validate a buffer address.
+ * @IPTS_STATUS_CMD_SIZE_ERROR:          Command contains an invalid payload.
+ * @IPTS_STATUS_NOT_READY:               Buffer addresses have not been set.
+ * @IPTS_STATUS_REQUEST_OUTSTANDING:     There is an outstanding command of the same type.
+ * @IPTS_STATUS_NO_SENSOR_FOUND:         No sensor could be found.
+ * @IPTS_STATUS_OUT_OF_MEMORY:           Not enough free memory for requested operation.
+ * @IPTS_STATUS_INTERNAL_ERROR:          An unexpected error occurred.
+ * @IPTS_STATUS_SENSOR_DISABLED:         The sensor has been disabled and must be reinitialized.
+ * @IPTS_STATUS_COMPAT_CHECK_FAIL:       Compatibility revision check between sensor and ME failed.
+ *                                       The host can ignore this error and attempt to continue.
+ * @IPTS_STATUS_SENSOR_EXPECTED_RESET:   The sensor went through a reset initiated by the driver.
+ * @IPTS_STATUS_SENSOR_UNEXPECTED_RESET: The sensor went through an unexpected reset.
+ * @IPTS_STATUS_RESET_FAILED:            Requested sensor reset failed to complete.
+ * @IPTS_STATUS_TIMEOUT:                 The operation timed out.
+ * @IPTS_STATUS_TEST_MODE_FAIL:          Test mode pattern did not match expected values.
+ * @IPTS_STATUS_SENSOR_FAIL_FATAL:       The sensor reported an error during reset sequence.
+ *                                       Further progress is not possible.
+ * @IPTS_STATUS_SENSOR_FAIL_NONFATAL:    The sensor reported an error during reset sequence.
+ *                                       The driver can attempt to continue.
+ * @IPTS_STATUS_INVALID_DEVICE_CAPS:     The device reported invalid capabilities.
+ * @IPTS_STATUS_QUIESCE_IO_IN_PROGRESS:  Command cannot be completed until Quiesce IO is done.
+ */
+enum ipts_status {
+	IPTS_STATUS_SUCCESS = 0x00,
+	IPTS_STATUS_INVALID_PARAMS = 0x01,
+	IPTS_STATUS_ACCESS_DENIED = 0x02,
+	IPTS_STATUS_CMD_SIZE_ERROR = 0x03,
+	IPTS_STATUS_NOT_READY = 0x04,
+	IPTS_STATUS_REQUEST_OUTSTANDING = 0x05,
+	IPTS_STATUS_NO_SENSOR_FOUND = 0x06,
+	IPTS_STATUS_OUT_OF_MEMORY = 0x07,
+	IPTS_STATUS_INTERNAL_ERROR = 0x08,
+	IPTS_STATUS_SENSOR_DISABLED = 0x09,
+	IPTS_STATUS_COMPAT_CHECK_FAIL = 0x0A,
+	IPTS_STATUS_SENSOR_EXPECTED_RESET = 0x0B,
+	IPTS_STATUS_SENSOR_UNEXPECTED_RESET = 0x0C,
+	IPTS_STATUS_RESET_FAILED = 0x0D,
+	IPTS_STATUS_TIMEOUT = 0x0E,
+	IPTS_STATUS_TEST_MODE_FAIL = 0x0F,
+	IPTS_STATUS_SENSOR_FAIL_FATAL = 0x10,
+	IPTS_STATUS_SENSOR_FAIL_NONFATAL = 0x11,
+	IPTS_STATUS_INVALID_DEVICE_CAPS = 0x12,
+	IPTS_STATUS_QUIESCE_IO_IN_PROGRESS = 0x13,
+};
+
+/**
+ * struct ipts_command - Message that is sent to the device for calling a command.
+ * @cmd:     The command that will be called.
+ * @payload: Payload containing parameters for the called command.
+ */
+struct ipts_command {
+	enum ipts_command_code cmd;
+	u8 payload[320];
+} __packed;
+
+static_assert(sizeof(struct ipts_command) == 324);
+
+/**
+ * enum ipts_mode - Configures what data the device produces and how its sent.
+ * @IPTS_MODE_EVENT:    The device will send an event once a buffer was filled.
+ *                      Older device will return singletouch data in this mode.
+ * @IPTS_MODE_DOORBELL: The device will notify the driver by incrementing the doorbell value.
+ *                      Older devices will return multitouch data in this mode.
+ */
+enum ipts_mode {
+	IPTS_MODE_EVENT = 0x00,
+	IPTS_MODE_DOORBELL = 0x01,
+};
+
+/**
+ * struct ipts_set_mode - Payload for the SET_MODE command.
+ * @mode: Changes the mode that IPTS will operate in.
+ */
+struct ipts_set_mode {
+	enum ipts_mode mode;
+	u8 reserved[12];
+} __packed;
+
+static_assert(sizeof(struct ipts_set_mode) == 16);
+
+#define IPTS_WORKQUEUE_SIZE	 8192
+#define IPTS_WORKQUEUE_ITEM_SIZE 16
+
+/**
+ * struct ipts_mem_window - Payload for the SET_MEM_WINDOW command.
+ * @data_addr_lower:      Lower 32 bits of the data buffer addresses.
+ * @data_addr_upper:      Upper 32 bits of the data buffer addresses.
+ * @workqueue_addr_lower: Lower 32 bits of the workqueue buffer address.
+ * @workqueue_addr_upper: Upper 32 bits of the workqueue buffer address.
+ * @doorbell_addr_lower:  Lower 32 bits of the doorbell buffer address.
+ * @doorbell_addr_upper:  Upper 32 bits of the doorbell buffer address.
+ * @feedbackaddr_lower:   Lower 32 bits of the feedback buffer addresses.
+ * @feedbackaddr_upper:   Upper 32 bits of the feedback buffer addresses.
+ * @hid2me_addr_lower:    Lower 32 bits of the hid2me buffer address.
+ * @hid2me_addr_upper:    Upper 32 bits of the hid2me buffer address.
+ * @hid2me_size:          Size of the hid2me feedback buffer.
+ * @workqueue_item_size:  Magic value. Must be 16.
+ * @workqueue_size:       Magic value. Must be 8192.
+ *
+ * The workqueue related items in this struct are required for using
+ * GuC submission with binary processing firmware. Since this driver does
+ * not use GuC submission and instead exports raw data to userspace, these
+ * items are not actually used, but they need to be allocated and passed
+ * to the device, otherwise initialization will fail.
+ */
+struct ipts_mem_window {
+	u32 data_addr_lower[IPTS_BUFFERS];
+	u32 data_addr_upper[IPTS_BUFFERS];
+	u32 workqueue_addr_lower;
+	u32 workqueue_addr_upper;
+	u32 doorbell_addr_lower;
+	u32 doorbell_addr_upper;
+	u32 feedback_addr_lower[IPTS_BUFFERS];
+	u32 feedback_addr_upper[IPTS_BUFFERS];
+	u32 hid2me_addr_lower;
+	u32 hid2me_addr_upper;
+	u32 hid2me_size;
+	u8 reserved1;
+	u8 workqueue_item_size;
+	u16 workqueue_size;
+	u8 reserved[32];
+} __packed;
+
+static_assert(sizeof(struct ipts_mem_window) == 320);
+
+/**
+ * struct ipts_quiesce_io - Payload for the QUIESCE_IO command.
+ */
+struct ipts_quiesce_io {
+	u8 reserved[12];
+} __packed;
+
+static_assert(sizeof(struct ipts_quiesce_io) == 12);
+
+/**
+ * struct ipts_feedback - Payload for the FEEDBACK command.
+ * @buffer: The buffer that the device should refill.
+ */
+struct ipts_feedback {
+	u32 buffer;
+	u8 reserved[12];
+} __packed;
+
+static_assert(sizeof(struct ipts_feedback) == 16);
+
+/**
+ * enum ipts_reset_type - Possible ways of resetting the device.
+ * @IPTS_RESET_TYPE_HARD: Perform hardware reset using GPIO pin.
+ * @IPTS_RESET_TYPE_SOFT: Perform software reset using SPI command.
+ */
+enum ipts_reset_type {
+	IPTS_RESET_TYPE_HARD = 0x00,
+	IPTS_RESET_TYPE_SOFT = 0x01,
+};
+
+/**
+ * struct ipts_reset - Payload for the RESET_SENSOR command.
+ * @type: How the device should get reset.
+ */
+struct ipts_reset_sensor {
+	enum ipts_reset_type type;
+	u8 reserved[4];
+} __packed;
+
+static_assert(sizeof(struct ipts_reset_sensor) == 8);
+
+/**
+ * struct ipts_get_descriptor - Payload for the GET_DESCRIPTOR command.
+ * @addr_lower: The lower 32 bits of the descriptor buffer address.
+ * @addr_upper: The upper 32 bits of the descriptor buffer address.
+ * @magic:      A magic value. Must be 8.
+ */
+struct ipts_get_descriptor {
+	u32 addr_lower;
+	u32 addr_upper;
+	u32 magic;
+	u8 reserved[12];
+} __packed;
+
+static_assert(sizeof(struct ipts_get_descriptor) == 24);
+
+/*
+ * The type of a response is indicated by a
+ * command code, with the most significant bit flipped to 1.
+ */
+#define IPTS_RSP_BIT BIT(31)
+
+/**
+ * struct ipts_response - Data returned from the device in response to a command.
+ * @cmd:     The command that this response answers (IPTS_RSP_BIT will be 1).
+ * @status:  The return code of the command.
+ * @payload: The data that was produced by the command.
+ */
+struct ipts_response {
+	enum ipts_command_code cmd;
+	enum ipts_status status;
+	u8 payload[80];
+} __packed;
+
+static_assert(sizeof(struct ipts_response) == 88);
+
+/**
+ * struct ipts_device_info - Vendor information of the IPTS device.
+ * @vendor:        Vendor ID of this device.
+ * @product:       Product ID of this device.
+ * @hw_version:    Hardware revision of this device.
+ * @fw_version:    Firmware revision of this device.
+ * @data_size:     Requested size for a data buffer.
+ * @feedback_size: Requested size for a feedback buffer.
+ * @mode:          Mode that the device currently operates in.
+ * @max_contacts:  Maximum amount of concurrent touches the sensor can process.
+ */
+struct ipts_device_info {
+	u16 vendor;
+	u16 product;
+	u32 hw_version;
+	u32 fw_version;
+	u32 data_size;
+	u32 feedback_size;
+	enum ipts_mode mode;
+	u8 max_contacts;
+	u8 reserved1[3];
+	u8 sensor_min_eds;
+	u8 sensor_maj_eds;
+	u8 me_min_eds;
+	u8 me_maj_eds;
+	u8 intf_eds;
+	u8 reserved2[11];
+} __packed;
+
+static_assert(sizeof(struct ipts_device_info) == 44);
+
+#endif /* IPTS_SPEC_DEVICE_H */
diff -Npur a/drivers/misc/ipts/spec-hid.h b/drivers/misc/ipts/spec-hid.h
--- a/drivers/misc/ipts/spec-hid.h	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/misc/ipts/spec-hid.h	2022-12-11 15:54:14.000000000 -0500
@@ -0,0 +1,35 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020-2022 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#ifndef IPTS_SPEC_HID_H
+#define IPTS_SPEC_HID_H
+
+#include <linux/build_bug.h>
+#include <linux/types.h>
+
+/*
+ * Made-up type for passing raw IPTS data in a HID report.
+ */
+#define IPTS_HID_FRAME_TYPE_RAW 0xEE
+
+/**
+ * struct ipts_hid_frame - Header that is prefixed to raw IPTS data wrapped in a HID report.
+ * @size: Size of the data inside the report, including this header.
+ * @type: What type of data does this report contain.
+ */
+struct ipts_hid_header {
+	u32 size;
+	u8 reserved1;
+	u8 type;
+	u8 reserved2;
+	u8 data[];
+} __packed;
+
+static_assert(sizeof(struct ipts_hid_header) == 7);
+
+#endif /* IPTS_SPEC_HID_H */
diff -Npur a/drivers/misc/ipts/uapi.c b/drivers/misc/ipts/uapi.c
--- a/drivers/misc/ipts/uapi.c	2022-12-24 14:05:14.978678975 -0500
+++ b/drivers/misc/ipts/uapi.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,208 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
-/*
- * Copyright (c) 2016 Intel Corporation
- * Copyright (c) 2020 Dorian Stoll
- *
- * Linux driver for Intel Precise Touch & Stylus
- */
-
-#include <linux/cdev.h>
-#include <linux/delay.h>
-#include <linux/device.h>
-#include <linux/fs.h>
-#include <linux/types.h>
-#include <linux/uaccess.h>
-
-#include "context.h"
-#include "control.h"
-#include "protocol.h"
-#include "uapi.h"
-
-struct ipts_uapi uapi;
-
-static ssize_t ipts_uapi_read(struct file *file, char __user *buf, size_t count,
-			      loff_t *offset)
-{
-	int buffer;
-	int maxbytes;
-	struct ipts_context *ipts = uapi.ipts;
-
-	buffer = MINOR(file->f_path.dentry->d_inode->i_rdev);
-
-	if (!ipts || ipts->status != IPTS_HOST_STATUS_STARTED)
-		return -ENODEV;
-
-	maxbytes = ipts->device_info.data_size - *offset;
-	if (maxbytes <= 0 || count > maxbytes)
-		return -EINVAL;
-
-	if (copy_to_user(buf, ipts->data[buffer].address + *offset, count))
-		return -EFAULT;
-
-	return count;
-}
-
-static long ipts_uapi_ioctl_get_device_ready(struct ipts_context *ipts,
-					     unsigned long arg)
-{
-	void __user *buffer = (void __user *)arg;
-	u8 ready = 0;
-
-	if (ipts)
-		ready = ipts->status == IPTS_HOST_STATUS_STARTED;
-
-	if (copy_to_user(buffer, &ready, sizeof(u8)))
-		return -EFAULT;
-
-	return 0;
-}
-
-static long ipts_uapi_ioctl_get_device_info(struct ipts_context *ipts,
-					    unsigned long arg)
-{
-	struct ipts_device_info info;
-	void __user *buffer = (void __user *)arg;
-
-	if (!ipts || ipts->status != IPTS_HOST_STATUS_STARTED)
-		return -ENODEV;
-
-	info.vendor = ipts->device_info.vendor_id;
-	info.product = ipts->device_info.device_id;
-	info.version = ipts->device_info.fw_rev;
-	info.buffer_size = ipts->device_info.data_size;
-	info.max_contacts = ipts->device_info.max_contacts;
-
-	if (copy_to_user(buffer, &info, sizeof(struct ipts_device_info)))
-		return -EFAULT;
-
-	return 0;
-}
-
-static long ipts_uapi_ioctl_get_doorbell(struct ipts_context *ipts,
-					 unsigned long arg)
-{
-	void __user *buffer = (void __user *)arg;
-
-	if (!ipts || ipts->status != IPTS_HOST_STATUS_STARTED)
-		return -ENODEV;
-
-	if (copy_to_user(buffer, ipts->doorbell.address, sizeof(u32)))
-		return -EFAULT;
-
-	return 0;
-}
-
-static long ipts_uapi_ioctl_send_feedback(struct ipts_context *ipts,
-					  struct file *file)
-{
-	int ret;
-	u32 buffer;
-
-	if (!ipts || ipts->status != IPTS_HOST_STATUS_STARTED)
-		return -ENODEV;
-
-	buffer = MINOR(file->f_path.dentry->d_inode->i_rdev);
-
-	ret = ipts_control_send_feedback(ipts, buffer);
-	if (ret)
-		return -EFAULT;
-
-	return 0;
-}
-
-static long ipts_uapi_ioctl_send_reset(struct ipts_context *ipts)
-{
-	int ret;
-	struct ipts_reset_sensor_cmd cmd;
-
-	if (!ipts || ipts->status != IPTS_HOST_STATUS_STARTED)
-		return -ENODEV;
-
-	memset(&cmd, 0, sizeof(struct ipts_reset_sensor_cmd));
-	cmd.type = IPTS_RESET_TYPE_SOFT;
-
-	ret = ipts_control_send(ipts, IPTS_CMD_RESET_SENSOR, &cmd,
-				sizeof(struct ipts_reset_sensor_cmd));
-
-	if (ret)
-		return -EFAULT;
-
-	return 0;
-}
-
-static long ipts_uapi_ioctl(struct file *file, unsigned int cmd,
-			    unsigned long arg)
-{
-	struct ipts_context *ipts = uapi.ipts;
-
-	switch (cmd) {
-	case IPTS_IOCTL_GET_DEVICE_READY:
-		return ipts_uapi_ioctl_get_device_ready(ipts, arg);
-	case IPTS_IOCTL_GET_DEVICE_INFO:
-		return ipts_uapi_ioctl_get_device_info(ipts, arg);
-	case IPTS_IOCTL_GET_DOORBELL:
-		return ipts_uapi_ioctl_get_doorbell(ipts, arg);
-	case IPTS_IOCTL_SEND_FEEDBACK:
-		return ipts_uapi_ioctl_send_feedback(ipts, file);
-	case IPTS_IOCTL_SEND_RESET:
-		return ipts_uapi_ioctl_send_reset(ipts);
-	default:
-		return -ENOTTY;
-	}
-}
-
-static const struct file_operations ipts_uapi_fops = {
-	.owner = THIS_MODULE,
-	.read = ipts_uapi_read,
-	.unlocked_ioctl = ipts_uapi_ioctl,
-#ifdef CONFIG_COMPAT
-	.compat_ioctl = ipts_uapi_ioctl,
-#endif
-};
-
-void ipts_uapi_link(struct ipts_context *ipts)
-{
-	uapi.ipts = ipts;
-}
-
-void ipts_uapi_unlink(void)
-{
-	uapi.ipts = NULL;
-}
-
-int ipts_uapi_init(void)
-{
-	int i, major;
-
-	alloc_chrdev_region(&uapi.dev, 0, IPTS_BUFFERS, "ipts");
-	uapi.class = class_create(THIS_MODULE, "ipts");
-
-	major = MAJOR(uapi.dev);
-
-	cdev_init(&uapi.cdev, &ipts_uapi_fops);
-	uapi.cdev.owner = THIS_MODULE;
-	cdev_add(&uapi.cdev, MKDEV(major, 0), IPTS_BUFFERS);
-
-	for (i = 0; i < IPTS_BUFFERS; i++) {
-		device_create(uapi.class, NULL, MKDEV(major, i), NULL,
-			      "ipts/%d", i);
-	}
-
-	return 0;
-}
-
-void ipts_uapi_free(void)
-{
-	int i;
-	int major;
-
-	major = MAJOR(uapi.dev);
-
-	for (i = 0; i < IPTS_BUFFERS; i++)
-		device_destroy(uapi.class, MKDEV(major, i));
-
-	cdev_del(&uapi.cdev);
-
-	unregister_chrdev_region(MKDEV(major, 0), MINORMASK);
-	class_destroy(uapi.class);
-}
diff -Npur a/drivers/misc/ipts/uapi.h b/drivers/misc/ipts/uapi.h
--- a/drivers/misc/ipts/uapi.h	2022-12-24 14:05:14.978678975 -0500
+++ b/drivers/misc/ipts/uapi.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,47 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-/*
- * Copyright (c) 2016 Intel Corporation
- * Copyright (c) 2020 Dorian Stoll
- *
- * Linux driver for Intel Precise Touch & Stylus
- */
-
-#ifndef _IPTS_UAPI_H_
-#define _IPTS_UAPI_H_
-
-#include <linux/types.h>
-
-#include "context.h"
-
-struct ipts_uapi {
-	dev_t dev;
-	struct class *class;
-	struct cdev cdev;
-
-	struct ipts_context *ipts;
-};
-
-struct ipts_device_info {
-	__u16 vendor;
-	__u16 product;
-	__u32 version;
-	__u32 buffer_size;
-	__u8 max_contacts;
-
-	/* For future expansion */
-	__u8 reserved[19];
-};
-
-#define IPTS_IOCTL_GET_DEVICE_READY _IOR(0x86, 0x01, __u8)
-#define IPTS_IOCTL_GET_DEVICE_INFO  _IOR(0x86, 0x02, struct ipts_device_info)
-#define IPTS_IOCTL_GET_DOORBELL	    _IOR(0x86, 0x03, __u32)
-#define IPTS_IOCTL_SEND_FEEDBACK    _IO(0x86, 0x04)
-#define IPTS_IOCTL_SEND_RESET	    _IO(0x86, 0x05)
-
-void ipts_uapi_link(struct ipts_context *ipts);
-void ipts_uapi_unlink(void);
-
-int ipts_uapi_init(void);
-void ipts_uapi_free(void);
-
-#endif /* _IPTS_UAPI_H_ */
