diff -Npur a/drivers/hid/ipts/cmd.c b/drivers/hid/ipts/cmd.c
--- a/drivers/hid/ipts/cmd.c	2023-01-15 22:49:44.452834932 -0500
+++ b/drivers/hid/ipts/cmd.c	2023-01-16 14:12:51.000000000 -0500
@@ -9,89 +9,44 @@
 #include <linux/errno.h>
 #include <linux/types.h>
 
+#include "cmd.h"
 #include "context.h"
+#include "mei.h"
 #include "spec-device.h"
 
-static int ipts_cmd_get_errno(struct ipts_response rsp, enum ipts_status expect)
+int ipts_cmd_recv_timeout(struct ipts_context *ipts, enum ipts_command_code code,
+			  struct ipts_response *rsp, u64 timeout)
 {
-	if (rsp.status == IPTS_STATUS_SUCCESS)
-		return 0;
-
-	/*
-	 * If a status code was expected, dont produce an error.
-	 */
-	if (rsp.status == expect)
-		return 0;
-
-	/*
-	 * Some devices will always return this error. It is allowed
-	 * to ignore it and to try continuing.
-	 */
-	if (rsp.status == IPTS_STATUS_COMPAT_CHECK_FAIL)
-		return 0;
-
-	/*
-	 * Return something, this is not going to be checked.
-	 * Any error will just cause the driver to stop.
-	 */
-	return -EINVAL;
-}
-
-static int _ipts_cmd_recv(struct ipts_context *ipts, enum ipts_command_code code, void *data,
-			  size_t size, bool block, enum ipts_status expect)
-{
-	int ret;
-	struct ipts_response rsp = { 0 };
+	int ret = 0;
 
 	if (!ipts)
 		return -EFAULT;
 
-	if (size > sizeof(rsp.payload))
-		return -EINVAL;
-
-	if (block)
-		ret = mei_cldev_recv(ipts->cldev, (u8 *)&rsp, sizeof(rsp));
-	else
-		ret = mei_cldev_recv_nonblock(ipts->cldev, (u8 *)&rsp, sizeof(rsp));
+	if (!rsp)
+		return -EFAULT;
 
-	if (ret == -EAGAIN)
+	/*
+	 * In a response, the command code will have the most significant bit flipped to 1.
+	 * If code is passed to ipts_mei_recv as is, no messages will be recevied.
+	 */
+	ret = ipts_mei_recv(&ipts->mei, code | IPTS_RSP_BIT, rsp, timeout);
+	if (ret < 0)
 		return ret;
 
-	if (ret <= 0) {
-		dev_err(ipts->dev, "Error while reading response: %d\n", ret);
-		return ret;
-	}
+	dev_dbg(ipts->dev, "Received 0x%02X with status 0x%02X\n", code, rsp->status);
 
 	/*
-	 * In a response, the command code will have the most significant bit
-	 * flipped to 1. We check for this and then set the bit to 0.
+	 * Some devices will always return this error.
+	 * It is allowed to ignore it and to try continuing.
 	 */
-	if ((rsp.cmd & IPTS_RSP_BIT) == 0) {
-		dev_err(ipts->dev, "Invalid command code received: 0x%02X\n", rsp.cmd);
-		return -EINVAL;
-	}
-
-	rsp.cmd = rsp.cmd & ~(IPTS_RSP_BIT);
-	if (rsp.cmd != code) {
-		dev_err(ipts->dev, "Received response to wrong command: 0x%02X\n", rsp.cmd);
-		return -EINVAL;
-	}
-
-	ret = ipts_cmd_get_errno(rsp, expect);
-	if (ret) {
-		dev_err(ipts->dev, "Command 0x%02X failed: 0x%02X\n", rsp.cmd, rsp.status);
-		return ret;
-	}
-
-	if (data && size > 0)
-		memcpy(data, rsp.payload, size);
+	if (rsp->status == IPTS_STATUS_COMPAT_CHECK_FAIL)
+		rsp->status = IPTS_STATUS_SUCCESS;
 
 	return 0;
 }
 
 int ipts_cmd_send(struct ipts_context *ipts, enum ipts_command_code code, void *data, size_t size)
 {
-	int ret;
 	struct ipts_command cmd = { 0 };
 
 	if (!ipts)
@@ -102,43 +57,6 @@ int ipts_cmd_send(struct ipts_context *i
 	if (data && size > 0)
 		memcpy(cmd.payload, data, size);
 
-	ret = mei_cldev_send(ipts->cldev, (u8 *)&cmd, sizeof(cmd.cmd) + size);
-	if (ret >= 0)
-		return 0;
-
-	dev_err(ipts->dev, "Error while sending: 0x%02X:%d\n", code, ret);
-	return ret;
-}
-
-int ipts_cmd_recv(struct ipts_context *ipts, enum ipts_command_code code, void *data, size_t size)
-{
-	return _ipts_cmd_recv(ipts, code, data, size, true, IPTS_STATUS_SUCCESS);
-}
-
-int ipts_cmd_recv_nonblock(struct ipts_context *ipts, enum ipts_command_code code, void *data,
-			   size_t size)
-{
-	return _ipts_cmd_recv(ipts, code, data, size, false, IPTS_STATUS_SUCCESS);
-}
-
-int ipts_cmd_recv_expect(struct ipts_context *ipts, enum ipts_command_code code, void *data,
-			 size_t size, enum ipts_status expect)
-{
-	return _ipts_cmd_recv(ipts, code, data, size, true, expect);
-}
-
-int ipts_cmd_run(struct ipts_context *ipts, enum ipts_command_code code, void *in, size_t insize,
-		 void *out, size_t outsize)
-{
-	int ret;
-
-	ret = ipts_cmd_send(ipts, code, in, insize);
-	if (ret)
-		return ret;
-
-	ret = ipts_cmd_recv(ipts, code, out, outsize);
-	if (ret)
-		return ret;
-
-	return 0;
+	dev_dbg(ipts->dev, "Sending 0x%02X with %ld bytes payload\n", code, size);
+	return ipts_mei_send(&ipts->mei, &cmd, sizeof(cmd.cmd) + size);
 }
diff -Npur a/drivers/hid/ipts/cmd.h b/drivers/hid/ipts/cmd.h
--- a/drivers/hid/ipts/cmd.h	2023-01-15 22:49:44.452834932 -0500
+++ b/drivers/hid/ipts/cmd.h	2023-01-16 14:12:51.000000000 -0500
@@ -15,37 +15,47 @@
 #include "spec-device.h"
 
 /*
- * Executes the specified command with the given payload on the device.
+ * The default timeout for receiving responses
  */
-int ipts_cmd_send(struct ipts_context *ipts, enum ipts_command_code code, void *data, size_t size);
-
-/*
- * Receives the response to the given command and copies the payload to the given buffer.
- * This function will block until a message has been received.
- */
-int ipts_cmd_recv(struct ipts_context *ipts, enum ipts_command_code code, void *data, size_t size);
+#define IPTS_CMD_DEFAULT_TIMEOUT 1000
 
 /*
- * Receives the response to the given command and copies the payload to the given buffer.
- * This function will not block. If no data is available, -EAGAIN will be returned.
- */
-int ipts_cmd_recv_nonblock(struct ipts_context *ipts, enum ipts_command_code code, void *data,
-			   size_t size);
+ * ipts_cmd_recv_timeout() - Receives a response to a command.
+ * @ipts: The IPTS driver context.
+ * @code: The type of the command / response.
+ * @rsp: The address that the received response will be copied to.
+ * @timeout: How many milliseconds the function will wait at most.
+ *
+ * A negative timeout means to wait forever.
+ *
+ * Returns: 0 on success, <0 on error, -EAGAIN if no response has been received.
+*/
+int ipts_cmd_recv_timeout(struct ipts_context *ipts, enum ipts_command_code code,
+			  struct ipts_response *rsp, u64 timeout);
 
 /*
- * Receives the response to the given command and copies the payload to the given buffer.
- * This function will block until a message has been received.
- * If the command finished with the expected status code, no error will be produced.
- */
-int ipts_cmd_recv_expect(struct ipts_context *ipts, enum ipts_command_code code, void *data,
-			 size_t size, enum ipts_status expect);
+ * ipts_cmd_recv() - Receives a response to a command.
+ * @ipts: The IPTS driver context.
+ * @code: The type of the command / response.
+ * @rsp: The address that the received response will be copied to.
+ *
+ * Returns: 0 on success, <0 on error, -EAGAIN if no response has been received.
+*/
+static inline int ipts_cmd_recv(struct ipts_context *ipts, enum ipts_command_code code,
+				struct ipts_response *rsp)
+{
+	return ipts_cmd_recv_timeout(ipts, code, rsp, IPTS_CMD_DEFAULT_TIMEOUT);
+}
 
 /*
- * Executes the specified command with the given payload on the device. Then
- * receives the response to the command and copies the payload to the given buffer.
- * This function will block until the command has been completed.
- */
-int ipts_cmd_run(struct ipts_context *ipts, enum ipts_command_code code, void *in, size_t insize,
-		 void *out, size_t outsize);
+ * ipts_cmd_send() - Executes a command on the device.
+ * @ipts: The IPTS driver context.
+ * @code: The type of the command to execute.
+ * @data: The payload containing parameters for the command.
+ * @size: The size of the payload.
+ *
+ * Returns: 0 on success, <0 on error.
+*/
+int ipts_cmd_send(struct ipts_context *ipts, enum ipts_command_code code, void *data, size_t size);
 
 #endif /* IPTS_CMD_H */
diff -Npur a/drivers/hid/ipts/context.h b/drivers/hid/ipts/context.h
--- a/drivers/hid/ipts/context.h	2023-01-15 22:49:44.452834932 -0500
+++ b/drivers/hid/ipts/context.h	2023-01-16 14:12:51.000000000 -0500
@@ -17,12 +17,13 @@
 #include <linux/sched.h>
 #include <linux/types.h>
 
+#include "mei.h"
 #include "resources.h"
 #include "spec-device.h"
 
 struct ipts_context {
 	struct device *dev;
-	struct mei_cl_device *cldev;
+	struct ipts_mei mei;
 
 	enum ipts_mode mode;
 
@@ -40,8 +41,7 @@ struct ipts_context {
 	struct ipts_device_info info;
 	struct ipts_resources resources;
 
-	struct task_struct *event_loop;
-	struct task_struct *doorbell_loop;
+	struct task_struct *receiver_loop;
 };
 
 #endif /* IPTS_CONTEXT_H */
diff -Npur a/drivers/hid/ipts/control.c b/drivers/hid/ipts/control.c
--- a/drivers/hid/ipts/control.c	2023-01-15 22:49:44.452834932 -0500
+++ b/drivers/hid/ipts/control.c	2023-01-16 14:12:51.000000000 -0500
@@ -25,23 +25,75 @@
 
 static int ipts_control_get_device_info(struct ipts_context *ipts, struct ipts_device_info *info)
 {
+	int ret = 0;
+	struct ipts_response rsp = { 0 };
+
+	if (!ipts)
+		return -EFAULT;
+
 	if (!info)
 		return -EFAULT;
 
-	return ipts_cmd_run(ipts, IPTS_CMD_GET_DEVICE_INFO, NULL, 0, info, sizeof(*info));
+	ret = ipts_cmd_send(ipts, IPTS_CMD_GET_DEVICE_INFO, NULL, 0);
+	if (ret) {
+		dev_err(ipts->dev, "GET_DEVICE_INFO: send failed: %d\n", ret);
+		return ret;
+	}
+
+	ret = ipts_cmd_recv(ipts, IPTS_CMD_GET_DEVICE_INFO, &rsp);
+	if (ret) {
+		dev_err(ipts->dev, "GET_DEVICE_INFO: recv failed: %d\n", ret);
+		return ret;
+	}
+
+	if (rsp.status != IPTS_STATUS_SUCCESS) {
+		dev_err(ipts->dev, "GET_DEVICE_INFO: cmd failed: %d\n", rsp.status);
+		return -EBADR;
+	}
+
+	memcpy(info, rsp.payload, sizeof(*info));
+	return 0;
 }
 
 static int ipts_control_set_mode(struct ipts_context *ipts, enum ipts_mode mode)
 {
+	int ret = 0;
 	struct ipts_set_mode cmd = { 0 };
+	struct ipts_response rsp = { 0 };
+
+	if (!ipts)
+		return -EFAULT;
 
 	cmd.mode = mode;
-	return ipts_cmd_run(ipts, IPTS_CMD_SET_MODE, &cmd, sizeof(cmd), NULL, 0);
+
+	ret = ipts_cmd_send(ipts, IPTS_CMD_SET_MODE, &cmd, sizeof(cmd));
+	if (ret) {
+		dev_err(ipts->dev, "SET_MODE: send failed: %d\n", ret);
+		return ret;
+	}
+
+	ret = ipts_cmd_recv(ipts, IPTS_CMD_SET_MODE, &rsp);
+	if (ret) {
+		dev_err(ipts->dev, "SET_MODE: recv failed: %d\n", ret);
+		return ret;
+	}
+
+	if (rsp.status != IPTS_STATUS_SUCCESS) {
+		dev_err(ipts->dev, "SET_MODE: cmd failed: %d\n", rsp.status);
+		return -EBADR;
+	}
+
+	return 0;
 }
 
 static int ipts_control_set_mem_window(struct ipts_context *ipts, struct ipts_resources *res)
 {
+	int ret = 0;
 	struct ipts_mem_window cmd = { 0 };
+	struct ipts_response rsp = { 0 };
+
+	if (!ipts)
+		return -EFAULT;
 
 	if (!res)
 		return -EFAULT;
@@ -65,43 +117,61 @@ static int ipts_control_set_mem_window(s
 	cmd.workqueue_size = IPTS_WORKQUEUE_SIZE;
 	cmd.workqueue_item_size = IPTS_WORKQUEUE_ITEM_SIZE;
 
-	return ipts_cmd_run(ipts, IPTS_CMD_SET_MEM_WINDOW, &cmd, sizeof(cmd), NULL, 0);
-}
-
-static int ipts_control_reset_sensor(struct ipts_context *ipts)
-{
-	struct ipts_feedback_header *header;
-
-	if (!ipts)
-		return -EFAULT;
+	ret = ipts_cmd_send(ipts, IPTS_CMD_SET_MEM_WINDOW, &cmd, sizeof(cmd));
+	if (ret) {
+		dev_err(ipts->dev, "SET_MEM_WINDOW: send failed: %d\n", ret);
+		return ret;
+	}
 
-	memset(ipts->resources.hid2me.address, 0, ipts->resources.hid2me.size);
-	header = (struct ipts_feedback_header *)ipts->resources.hid2me.address;
+	ret = ipts_cmd_recv(ipts, IPTS_CMD_SET_MEM_WINDOW, &rsp);
+	if (ret) {
+		dev_err(ipts->dev, "SET_MEM_WINDOW: recv failed: %d\n", ret);
+		return ret;
+	}
 
-	header->cmd_type = IPTS_FEEDBACK_CMD_TYPE_SOFT_RESET;
-	header->buffer = IPTS_HID2ME_BUFFER;
+	if (rsp.status != IPTS_STATUS_SUCCESS) {
+		dev_err(ipts->dev, "SET_MEM_WINDOW: cmd failed: %d\n", rsp.status);
+		return -EBADR;
+	}
 
-	return ipts_control_send_feedback(ipts, IPTS_HID2ME_BUFFER);
+	return 0;
 }
 
 static int ipts_control_get_descriptor(struct ipts_context *ipts)
 {
-	int ret;
-	struct ipts_data_header *header;
+	int ret = 0;
+	struct ipts_data_header *header = NULL;
 	struct ipts_get_descriptor cmd = { 0 };
+	struct ipts_response rsp = { 0 };
 
 	if (!ipts)
 		return -EFAULT;
 
+	if (!ipts->resources.descriptor.address)
+		return -EFAULT;
+
 	memset(ipts->resources.descriptor.address, 0, ipts->resources.descriptor.size);
 
 	cmd.addr_lower = lower_32_bits(ipts->resources.descriptor.dma_address);
 	cmd.addr_upper = upper_32_bits(ipts->resources.descriptor.dma_address);
 	cmd.magic = 8;
 
-	ret = ipts_cmd_run(ipts, IPTS_CMD_GET_DESCRIPTOR, &cmd, sizeof(cmd), NULL, 0);
-	if (ret)
+	ret = ipts_cmd_send(ipts, IPTS_CMD_GET_DESCRIPTOR, &cmd, sizeof(cmd));
+	if (ret) {
+		dev_err(ipts->dev, "GET_DESCRIPTOR: send failed: %d\n", ret);
 		return ret;
+	}
+
+	ret = ipts_cmd_recv(ipts, IPTS_CMD_GET_DESCRIPTOR, &rsp);
+	if (ret) {
+		dev_err(ipts->dev, "GET_DESCRIPTOR: recv failed: %d\n", ret);
+		return ret;
+	}
+
+	if (rsp.status != IPTS_STATUS_SUCCESS) {
+		dev_err(ipts->dev, "GET_DESCRIPTOR: cmd failed: %d\n", rsp.status);
+		return -EBADR;
+	}
 
 	header = (struct ipts_data_header *)ipts->resources.descriptor.address;
 
@@ -112,69 +182,175 @@ static int ipts_control_get_descriptor(s
 		return 0;
 	}
 
-	return -EINVAL;
+	return -ENODATA;
 }
 
 int ipts_control_request_flush(struct ipts_context *ipts)
 {
+	int ret = 0;
 	struct ipts_quiesce_io cmd = { 0 };
 
-	return ipts_cmd_send(ipts, IPTS_CMD_QUIESCE_IO, &cmd, sizeof(cmd));
+	if (!ipts)
+		return -EFAULT;
+
+	ret = ipts_cmd_send(ipts, IPTS_CMD_QUIESCE_IO, &cmd, sizeof(cmd));
+	if (ret)
+		dev_err(ipts->dev, "QUIESCE_IO: send failed: %d\n", ret);
+
+	return ret;
 }
 
 int ipts_control_wait_flush(struct ipts_context *ipts)
 {
-	return ipts_cmd_recv(ipts, IPTS_CMD_QUIESCE_IO, NULL, 0);
+	int ret = 0;
+	struct ipts_response rsp = { 0 };
+
+	if (!ipts)
+		return -EFAULT;
+
+	ret = ipts_cmd_recv(ipts, IPTS_CMD_QUIESCE_IO, &rsp);
+	if (ret) {
+		dev_err(ipts->dev, "QUIESCE_IO: recv failed: %d\n", ret);
+		return ret;
+	}
+
+	if (rsp.status == IPTS_STATUS_TIMEOUT)
+		return -EAGAIN;
+
+	if (rsp.status != IPTS_STATUS_SUCCESS) {
+		dev_err(ipts->dev, "QUIESCE_IO: cmd failed: %d\n", rsp.status);
+		return -EBADR;
+	}
+
+	return 0;
 }
 
 int ipts_control_request_data(struct ipts_context *ipts)
 {
-	return ipts_cmd_send(ipts, IPTS_CMD_READY_FOR_DATA, NULL, 0);
+	int ret = 0;
+
+	if (!ipts)
+		return -EFAULT;
+
+	ret = ipts_cmd_send(ipts, IPTS_CMD_READY_FOR_DATA, NULL, 0);
+	if (ret)
+		dev_err(ipts->dev, "READY_FOR_DATA: send failed: %d\n", ret);
+
+	return ret;
 }
 
 int ipts_control_wait_data(struct ipts_context *ipts, bool shutdown)
 {
+	int ret = 0;
+	struct ipts_response rsp = { 0 };
+
+	if (!ipts)
+		return -EFAULT;
+
 	if (!shutdown)
-		return ipts_cmd_recv_nonblock(ipts, IPTS_CMD_READY_FOR_DATA, NULL, 0);
+		ret = ipts_cmd_recv_timeout(ipts, IPTS_CMD_READY_FOR_DATA, &rsp, 0);
+	else
+		ret = ipts_cmd_recv(ipts, IPTS_CMD_READY_FOR_DATA, &rsp);
 
-	return ipts_cmd_recv_expect(ipts, IPTS_CMD_READY_FOR_DATA, NULL, 0,
-				    IPTS_STATUS_SENSOR_DISABLED);
+	if (ret) {
+		if (ret != -EAGAIN)
+			dev_err(ipts->dev, "READY_FOR_DATA: recv failed: %d\n", ret);
+
+		return ret;
+	}
+
+	/*
+	 * During shutdown, it is possible that the sensor has already been disabled.
+	*/
+	if (rsp.status == IPTS_STATUS_SENSOR_DISABLED)
+		return 0;
+
+	if (rsp.status == IPTS_STATUS_TIMEOUT)
+		return -EAGAIN;
+
+	if (rsp.status != IPTS_STATUS_SUCCESS) {
+		dev_err(ipts->dev, "READY_FOR_DATA: cmd failed: %d\n", rsp.status);
+		return -EBADR;
+	}
+
+	return 0;
 }
 
 int ipts_control_send_feedback(struct ipts_context *ipts, u32 buffer)
 {
-	int ret;
+	int ret = 0;
 	struct ipts_feedback cmd = { 0 };
+	struct ipts_response rsp = { 0 };
+
+	if (!ipts)
+		return -EFAULT;
 
 	cmd.buffer = buffer;
 
 	ret = ipts_cmd_send(ipts, IPTS_CMD_FEEDBACK, &cmd, sizeof(cmd));
-	if (ret)
+	if (ret) {
+		dev_err(ipts->dev, "FEEDBACK: send failed: %d\n", ret);
 		return ret;
+	}
+
+	ret = ipts_cmd_recv(ipts, IPTS_CMD_FEEDBACK, &rsp);
+	if (ret) {
+		dev_err(ipts->dev, "FEEDBACK: recv failed: %d\n", ret);
+		return ret;
+	}
 
-	return ipts_cmd_recv_expect(ipts, IPTS_CMD_FEEDBACK, NULL, 0, IPTS_STATUS_INVALID_PARAMS);
+	/*
+	 * Explained below, we don't know what feedback data looks like so we are sending zeros.
+	 */
+	if (rsp.status == IPTS_STATUS_INVALID_PARAMS)
+		return 0;
+
+	if (rsp.status != IPTS_STATUS_SUCCESS) {
+		dev_err(ipts->dev, "FEEDBACK: cmd failed: %d\n", rsp.status);
+		return -EBADR;
+	}
+
+	return 0;
 }
 
-int ipts_control_refill_buffer(struct ipts_context *ipts, u32 buffer)
+int ipts_control_hid2me_feedback(struct ipts_context *ipts, enum ipts_feedback_cmd_type cmd,
+				 enum ipts_feedback_data_type type, void *data, size_t size)
 {
+	struct ipts_feedback_header *header = NULL;
+
 	if (!ipts)
 		return -EFAULT;
 
-	/*
-	 * IPTS expects structured data in the feedback buffer matching the buffer that will be refilled.
-	 * We don't know what that data looks like, so we just keep the buffer empty.
-	 * This results in an INVALID_PARAMS error, but the buffer gets refilled without an issue.
-	 * Sending a minimal structure with the buffer ID fixes the error, but breaks refilling
-	 * the buffers on some devices.
-	 */
+	if (!ipts->resources.hid2me.address)
+		return -EFAULT;
+
+	memset(ipts->resources.hid2me.address, 0, ipts->resources.hid2me.size);
+	header = (struct ipts_feedback_header *)ipts->resources.hid2me.address;
+
+	header->cmd_type = cmd;
+	header->data_type = type;
+	header->size = size;
+	header->buffer = IPTS_HID2ME_BUFFER;
+
+	if (size + sizeof(*header) > ipts->resources.hid2me.size)
+		return -EINVAL;
+
+	if (data && size > 0)
+		memcpy(header->payload, data, size);
 
-	return ipts_control_send_feedback(ipts, buffer);
+	return ipts_control_send_feedback(ipts, IPTS_HID2ME_BUFFER);
+}
+
+static inline int ipts_control_reset_sensor(struct ipts_context *ipts)
+{
+	return ipts_control_hid2me_feedback(ipts, IPTS_FEEDBACK_CMD_TYPE_SOFT_RESET,
+					    IPTS_FEEDBACK_DATA_TYPE_VENDOR, NULL, 0);
 }
 
 int ipts_control_start(struct ipts_context *ipts)
 {
-	int ret;
-	struct ipts_device_info info;
+	int ret = 0;
+	struct ipts_device_info info = { 0 };
 
 	if (!ipts)
 		return -EFAULT;
@@ -229,7 +405,11 @@ int ipts_control_start(struct ipts_conte
 		return ret;
 	}
 
-	ipts_receiver_start(ipts);
+	ret = ipts_receiver_start(ipts);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to start receiver: %d\n", ret);
+		return ret;
+	}
 
 	ret = ipts_control_request_data(ipts);
 	if (ret) {
@@ -248,13 +428,18 @@ int ipts_control_start(struct ipts_conte
 
 static int _ipts_control_stop(struct ipts_context *ipts)
 {
-	int ret;
+	int ret = 0;
 
 	if (!ipts)
 		return -EFAULT;
 
 	dev_info(ipts->dev, "Stopping IPTS\n");
-	ipts_receiver_stop(ipts);
+
+	ret = ipts_receiver_stop(ipts);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to stop receiver: %d\n", ret);
+		return ret;
+	}
 
 	ret = ipts_control_reset_sensor(ipts);
 	if (ret) {
@@ -262,26 +447,35 @@ static int _ipts_control_stop(struct ipt
 		return ret;
 	}
 
-	ipts_resources_free(&ipts->resources);
+	ret = ipts_resources_free(&ipts->resources);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to free resources: %d\n", ret);
+		return ret;
+	}
+
 	return 0;
 }
 
 int ipts_control_stop(struct ipts_context *ipts)
 {
-	int ret;
+	int ret = 0;
 
 	ret = _ipts_control_stop(ipts);
 	if (ret)
 		return ret;
 
-	ipts_hid_free(ipts);
+	ret = ipts_hid_free(ipts);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to free HID device: %d\n", ret);
+		return ret;
+	}
 
 	return 0;
 }
 
 int ipts_control_restart(struct ipts_context *ipts)
 {
-	int ret;
+	int ret = 0;
 
 	ret = _ipts_control_stop(ipts);
 	if (ret)
@@ -290,7 +484,7 @@ int ipts_control_restart(struct ipts_con
 	/*
 	 * Give the sensor some time to come back from resetting
 	 */
-	msleep(1500);
+	msleep(1600);
 
 	ret = ipts_control_start(ipts);
 	if (ret)
diff -Npur a/drivers/hid/ipts/control.h b/drivers/hid/ipts/control.h
--- a/drivers/hid/ipts/control.h	2023-01-15 22:49:44.453834936 -0500
+++ b/drivers/hid/ipts/control.h	2023-01-16 14:12:51.000000000 -0500
@@ -12,61 +12,115 @@
 #include <linux/types.h>
 
 #include "context.h"
+#include "spec-data.h"
 #include "spec-device.h"
 
 /*
- * Sends a request to stop the data flow to the device.
- * All outstanding data needs to be acknowledged using
- * feedback before the request can be finalized.
- */
+ * ipts_control_request_flush() - Stop the data flow.
+ * @ipts: The IPTS driver context.
+ *
+ * Runs the command to stop the data flow on the device.
+ * All outstanding data needs to be acknowledged using feedback before the command will return.
+ *
+ * Returns: 0 on success, <0 on error.
+*/
 int ipts_control_request_flush(struct ipts_context *ipts);
 
 /*
- * Waits until the flushing request has been finalized.
- */
+ * ipts_control_wait_flush() - Wait until data flow has been stopped.
+ * @ipts: The IPTS driver context.
+ *
+ * Returns: 0 on success, <0 on error.
+*/
 int ipts_control_wait_flush(struct ipts_context *ipts);
 
 /*
- * Notify the device that the driver can receive new data.
- */
+ * ipts_control_wait_flush() - Notify the device that the driver can receive new data.
+ * @ipts: The IPTS driver context.
+ *
+ * Returns: 0 on success, <0 on error.
+*/
 int ipts_control_request_data(struct ipts_context *ipts);
 
 /*
- * Wait until new data is available on the device.
- * In doorbell mode, this function will never return while the data
- * flow is active. Instead, the doorbell will be incremented when new
- * data is available.
+ * ipts_control_wait_data() - Wait until new data is available.
+ * @ipts: The IPTS driver context.
+ * @block: Whether to block execution until data is available.
  *
- * If shutdown == true, the function will block, and errors that are
- * produced by the device due to a disabled sensor will be ignored.
+ * In doorbell mode, this function will never return while the data flow is active. Instead,
+ * the doorbell will be incremented when new data is available.
  *
- * If shutdown == false, the function will not block. If no data is
- * available, -EAGAIN will be returned.
- */
-int ipts_control_wait_data(struct ipts_context *ipts, bool shutdown);
+ * Returns: 0 on success, <0 on error, -EAGAIN if no data is available.
+*/
+int ipts_control_wait_data(struct ipts_context *ipts, bool block);
 
 /*
- * Submits the given feedback buffer to the hardware.
- */
+ * ipts_control_send_feedback() - Submits a feedback buffer to the device.
+ * @ipts: The IPTS driver context.
+ * @buffer: The ID of the buffer containing feedback data.
+ *
+ * Returns: 0 on success, <0 on error.
+*/
 int ipts_control_send_feedback(struct ipts_context *ipts, u32 buffer);
 
 /*
- * Acknowledges that the data in a buffer has been processed.
+ * ipts_control_hid2me_feedback() - Sends HID2ME feedback, a special type of feedback.
+ * @ipts: The IPTS driver context.
+ * @cmd: The command that will be run on the device.
+ * @type: The type of the payload that is sent to the device.
+ * @data: The payload of the feedback command.
+ * @size: The size of the payload.
+ *
+ * HID2ME feedback is a special type of feedback, because it allows interfacing with
+ * the HID API of the device at any moment, without requiring a buffer that has to
+ * be acknowledged.
+ *
+ * Returns: 0 on success, <0 on error.
+ */
+int ipts_control_hid2me_feedback(struct ipts_context *ipts, enum ipts_feedback_cmd_type cmd,
+				 enum ipts_feedback_data_type type, void *data, size_t size);
+
+/*
+ * ipts_control_refill_buffer() - Acknowledges that data in a buffer has been processed.
+ * @ipts: The IPTS driver context.
+ * @buffer: The buffer that has been processed and can be refilled.
+ *
+ * Returns: 0 on success, <0 on error.
  */
-int ipts_control_refill_buffer(struct ipts_context *ipts, u32 buffer);
+static inline int ipts_control_refill_buffer(struct ipts_context *ipts, u32 buffer)
+{
+	/*
+	 * IPTS expects structured data in the feedback buffer matching the buffer that will be refilled.
+	 * We don't know what that data looks like, so we just keep the buffer empty.
+	 * This results in an INVALID_PARAMS error, but the buffer gets refilled without an issue.
+	 * Sending a minimal structure with the buffer ID fixes the error, but breaks refilling
+	 * the buffers on some devices.
+	 */
+
+	return ipts_control_send_feedback(ipts, buffer);
+}
 
 /*
- * Initializes the IPTS device and starts the data flow.
+ * ipts_control_start() - Initialized the device and starts the data flow.
+ * @ipts: The IPTS driver context.
+ *
+ * Returns: 0 on success, <0 on error.
  */
 int ipts_control_start(struct ipts_context *ipts);
 
 /*
- * Stops the data flow and resets the device.
+ * ipts_control_stop() - Stops the data flow and resets the device.
+ * @ipts: The IPTS driver context.
+ *
+ * Returns: 0 on success, <0 on error.
  */
 int ipts_control_stop(struct ipts_context *ipts);
 
 /*
- * Stops the device and immideately starts it again.
+ * ipts_control_restart() - Stops the device and starts it again.
+ * @ipts: The IPTS driver context.
+ *
+ * Returns: 0 on success, <0 on error.
  */
 int ipts_control_restart(struct ipts_context *ipts);
 
diff -Npur a/drivers/hid/ipts/hid.c b/drivers/hid/ipts/hid.c
--- a/drivers/hid/ipts/hid.c	2023-01-15 22:49:44.453834936 -0500
+++ b/drivers/hid/ipts/hid.c	2023-01-16 14:12:51.000000000 -0500
@@ -30,31 +30,6 @@ static void ipts_hid_stop(struct hid_dev
 {
 }
 
-static int ipts_hid_hid2me_feedback(struct ipts_context *ipts, enum ipts_feedback_data_type type,
-				    void *data, size_t size)
-{
-	struct ipts_feedback_header *header;
-
-	if (!ipts)
-		return -EFAULT;
-
-	memset(ipts->resources.hid2me.address, 0, ipts->resources.hid2me.size);
-	header = (struct ipts_feedback_header *)ipts->resources.hid2me.address;
-
-	header->cmd_type = IPTS_FEEDBACK_CMD_TYPE_NONE;
-	header->buffer = IPTS_HID2ME_BUFFER;
-	header->data_type = type;
-	header->size = size;
-
-	if (size + sizeof(*header) > ipts->resources.hid2me.size)
-		return -EINVAL;
-
-	if (data && size > 0)
-		memcpy(header->payload, data, size);
-
-	return ipts_control_send_feedback(ipts, IPTS_HID2ME_BUFFER);
-}
-
 static int ipts_hid_switch_mode(struct ipts_context *ipts, enum ipts_mode mode)
 {
 	if (!ipts)
@@ -75,14 +50,16 @@ static int ipts_hid_switch_mode(struct i
 
 static int ipts_hid_parse(struct hid_device *hid)
 {
-	int ret;
-	u8 *buffer;
-	size_t size;
-	struct ipts_context *ipts;
-	bool has_native_descriptor;
+	int ret = 0;
+	struct ipts_context *ipts = NULL;
+
+	bool has_native_descriptor = false;
+
+	u8 *buffer = NULL;
+	size_t size = 0;
 
 	if (!hid)
-		return -EFAULT;
+		return -ENODEV;
 
 	ipts = hid->driver_data;
 
@@ -98,6 +75,9 @@ static int ipts_hid_parse(struct hid_dev
 		size += sizeof(ipts_fallback_descriptor);
 
 	buffer = kzalloc(size, GFP_KERNEL);
+	if (!buffer)
+		return -ENOMEM;
+
 	memcpy(buffer, ipts_singletouch_descriptor, sizeof(ipts_singletouch_descriptor));
 
 	if (has_native_descriptor) {
@@ -122,7 +102,13 @@ static int ipts_hid_parse(struct hid_dev
 static int ipts_hid_get_feature(struct ipts_context *ipts, unsigned char reportnum, __u8 *buf,
 				size_t size, enum ipts_feedback_data_type type)
 {
-	int ret;
+	int ret = 0;
+
+	if (!ipts)
+		return -EFAULT;
+
+	if (!buf)
+		return -EFAULT;
 
 	mutex_lock(&ipts->feature_lock);
 
@@ -132,7 +118,7 @@ static int ipts_hid_get_feature(struct i
 	memset(&ipts->feature_report, 0, sizeof(ipts->feature_report));
 	reinit_completion(&ipts->feature_event);
 
-	ret = ipts_hid_hid2me_feedback(ipts, type, buf, size);
+	ret = ipts_control_hid2me_feedback(ipts, IPTS_FEEDBACK_CMD_TYPE_NONE, type, buf, size);
 	if (ret) {
 		dev_err(ipts->dev, "Failed to send hid2me feedback: %d\n", ret);
 		goto out;
@@ -166,11 +152,17 @@ out:
 static int ipts_hid_set_feature(struct ipts_context *ipts, unsigned char reportnum, __u8 *buf,
 				size_t size, enum ipts_feedback_data_type type)
 {
-	int ret;
+	int ret = 0;
+
+	if (!ipts)
+		return -EFAULT;
+
+	if (!buf)
+		return -EFAULT;
 
 	buf[0] = reportnum;
 
-	ret = ipts_hid_hid2me_feedback(ipts, type, buf, size);
+	ret = ipts_control_hid2me_feedback(ipts, IPTS_FEEDBACK_CMD_TYPE_NONE, type, buf, size);
 	if (ret)
 		dev_err(ipts->dev, "Failed to send hid2me feedback: %d\n", ret);
 
@@ -180,12 +172,13 @@ static int ipts_hid_set_feature(struct i
 static int ipts_hid_raw_request(struct hid_device *hid, unsigned char reportnum, __u8 *buf,
 				size_t size, unsigned char rtype, int reqtype)
 {
-	int ret;
-	enum ipts_feedback_data_type type;
-	struct ipts_context *ipts;
+	int ret = 0;
+	struct ipts_context *ipts = NULL;
+
+	enum ipts_feedback_data_type type = IPTS_FEEDBACK_DATA_TYPE_VENDOR;
 
 	if (!hid)
-		return -EFAULT;
+		return -ENODEV;
 
 	ipts = hid->driver_data;
 
@@ -221,20 +214,15 @@ static int ipts_hid_raw_request(struct h
 
 static int ipts_hid_output_report(struct hid_device *hid, __u8 *data, size_t size)
 {
-	struct ipts_context *ipts;
+	struct ipts_context *ipts = NULL;
 
 	if (!hid)
-		return -EFAULT;
+		return -ENODEV;
 
 	ipts = hid->driver_data;
 
-	if (!ipts)
-		return -EFAULT;
-
-	if (!data)
-		return -EFAULT;
-
-	return ipts_hid_hid2me_feedback(ipts, IPTS_FEEDBACK_DATA_TYPE_OUTPUT_REPORT, data, size);
+	return ipts_control_hid2me_feedback(ipts, IPTS_FEEDBACK_CMD_TYPE_NONE,
+					    IPTS_FEEDBACK_DATA_TYPE_OUTPUT_REPORT, data, size);
 }
 
 static struct hid_ll_driver ipts_hid_driver = {
@@ -247,12 +235,12 @@ static struct hid_ll_driver ipts_hid_dri
 	.output_report = ipts_hid_output_report,
 };
 
-int ipts_hid_input_data(struct ipts_context *ipts, int buffer)
+int ipts_hid_input_data(struct ipts_context *ipts, u32 buffer)
 {
-	int ret;
-	u8 *temp;
-	struct ipts_hid_header *frame;
-	struct ipts_data_header *header;
+	int ret = 0;
+	u8 *temp = NULL;
+	struct ipts_hid_header *frame = NULL;
+	struct ipts_data_header *header = NULL;
 
 	if (!ipts)
 		return -EFAULT;
@@ -262,6 +250,9 @@ int ipts_hid_input_data(struct ipts_cont
 
 	header = (struct ipts_data_header *)ipts->resources.data[buffer].address;
 
+	if (!header)
+		return -EFAULT;
+
 	if (header->size == 0)
 		return 0;
 
@@ -305,7 +296,7 @@ int ipts_hid_input_data(struct ipts_cont
 
 int ipts_hid_init(struct ipts_context *ipts, struct ipts_device_info info)
 {
-	int ret;
+	int ret = 0;
 
 	if (!ipts)
 		return -EFAULT;
@@ -315,8 +306,10 @@ int ipts_hid_init(struct ipts_context *i
 
 	ipts->hid = hid_allocate_device();
 	if (IS_ERR(ipts->hid)) {
-		dev_err(ipts->dev, "Failed to allocate HID device: %ld\n", PTR_ERR(ipts->hid));
-		return PTR_ERR(ipts->hid);
+		int err = PTR_ERR(ipts->hid);
+
+		dev_err(ipts->dev, "Failed to allocate HID device: %d\n", err);
+		return err;
 	}
 
 	ipts->hid->driver_data = ipts;
@@ -340,8 +333,16 @@ int ipts_hid_init(struct ipts_context *i
 	return 0;
 }
 
-void ipts_hid_free(struct ipts_context *ipts)
+int ipts_hid_free(struct ipts_context *ipts)
 {
+	if (!ipts)
+		return -EFAULT;
+
+	if (!ipts->hid)
+		return 0;
+
 	hid_destroy_device(ipts->hid);
 	ipts->hid = NULL;
+
+	return 0;
 }
diff -Npur a/drivers/hid/ipts/hid.h b/drivers/hid/ipts/hid.h
--- a/drivers/hid/ipts/hid.h	2023-01-15 22:49:44.453834936 -0500
+++ b/drivers/hid/ipts/hid.h	2023-01-16 14:12:51.000000000 -0500
@@ -14,9 +14,9 @@
 #include "context.h"
 #include "spec-device.h"
 
-int ipts_hid_input_data(struct ipts_context *ipts, int buffer);
+int ipts_hid_input_data(struct ipts_context *ipts, u32 buffer);
 
 int ipts_hid_init(struct ipts_context *ipts, struct ipts_device_info info);
-void ipts_hid_free(struct ipts_context *ipts);
+int ipts_hid_free(struct ipts_context *ipts);
 
 #endif /* IPTS_HID_H */
diff -Npur a/drivers/hid/ipts/main.c b/drivers/hid/ipts/main.c
--- a/drivers/hid/ipts/main.c	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/hid/ipts/main.c	2023-01-16 14:12:51.000000000 -0500
@@ -0,0 +1,127 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020-2022 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#include <linux/completion.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/mei_cl_bus.h>
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/stddef.h>
+#include <linux/types.h>
+
+#include "context.h"
+#include "control.h"
+#include "mei.h"
+#include "receiver.h"
+#include "spec-device.h"
+
+/*
+ * The MEI client ID for IPTS functionality.
+ */
+#define IPTS_ID UUID_LE(0x3e8d0870, 0x271a, 0x4208, 0x8e, 0xb5, 0x9a, 0xcb, 0x94, 0x02, 0xae, 0x04)
+
+static int ipts_set_dma_mask(struct mei_cl_device *cldev)
+{
+	if (!cldev)
+		return -EFAULT;
+
+	if (!dma_coerce_mask_and_coherent(&cldev->dev, DMA_BIT_MASK(64)))
+		return 0;
+
+	return dma_coerce_mask_and_coherent(&cldev->dev, DMA_BIT_MASK(32));
+}
+
+static int ipts_probe(struct mei_cl_device *cldev, const struct mei_cl_device_id *id)
+{
+	int ret = 0;
+	struct ipts_context *ipts = NULL;
+
+	if (!cldev)
+		return -EFAULT;
+
+	ret = ipts_set_dma_mask(cldev);
+	if (ret) {
+		dev_err(&cldev->dev, "Failed to set DMA mask for IPTS: %d\n", ret);
+		return ret;
+	}
+
+	ret = mei_cldev_enable(cldev);
+	if (ret) {
+		dev_err(&cldev->dev, "Failed to enable MEI device: %d\n", ret);
+		return ret;
+	}
+
+	ipts = devm_kzalloc(&cldev->dev, sizeof(*ipts), GFP_KERNEL);
+	if (!ipts) {
+		mei_cldev_disable(cldev);
+		return -ENOMEM;
+	}
+
+	ret = ipts_mei_init(&ipts->mei, cldev);
+	if (ret) {
+		dev_err(&cldev->dev, "Failed to init MEI bus logic: %d\n", ret);
+		return ret;
+	}
+
+	ipts->dev = &cldev->dev;
+	ipts->mode = IPTS_MODE_EVENT;
+
+	mutex_init(&ipts->feature_lock);
+	init_completion(&ipts->feature_event);
+
+	mei_cldev_set_drvdata(cldev, ipts);
+
+	ret = ipts_control_start(ipts);
+	if (ret) {
+		dev_err(&cldev->dev, "Failed to start IPTS: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void ipts_remove(struct mei_cl_device *cldev)
+{
+	int ret = 0;
+	struct ipts_context *ipts = NULL;
+
+	if (!cldev) {
+		pr_err("MEI device is NULL!");
+		return;
+	}
+
+	ipts = mei_cldev_get_drvdata(cldev);
+
+	ret = ipts_control_stop(ipts);
+	if (ret)
+		dev_err(&cldev->dev, "Failed to stop IPTS: %d\n", ret);
+
+	mei_cldev_disable(cldev);
+}
+
+static struct mei_cl_device_id ipts_device_id_table[] = {
+	{ .uuid = IPTS_ID, .version = MEI_CL_VERSION_ANY },
+	{},
+};
+MODULE_DEVICE_TABLE(mei, ipts_device_id_table);
+
+static struct mei_cl_driver ipts_driver = {
+	.id_table = ipts_device_id_table,
+	.name = "ipts",
+	.probe = ipts_probe,
+	.remove = ipts_remove,
+};
+module_mei_cl_driver(ipts_driver);
+
+MODULE_DESCRIPTION("IPTS touchscreen driver");
+MODULE_AUTHOR("Dorian Stoll <dorian.stoll@tmsp.io>");
+MODULE_LICENSE("GPL");
diff -Npur a/drivers/hid/ipts/Makefile b/drivers/hid/ipts/Makefile
--- a/drivers/hid/ipts/Makefile	2023-01-15 22:49:44.453834936 -0500
+++ b/drivers/hid/ipts/Makefile	2023-01-16 14:12:51.000000000 -0500
@@ -7,6 +7,7 @@ obj-$(CONFIG_HID_IPTS) += ipts.o
 ipts-objs := cmd.o
 ipts-objs += control.o
 ipts-objs += hid.o
+ipts-objs += main.o
 ipts-objs += mei.o
 ipts-objs += receiver.o
 ipts-objs += resources.o
diff -Npur a/drivers/hid/ipts/mei.c b/drivers/hid/ipts/mei.c
--- a/drivers/hid/ipts/mei.c	2023-01-15 22:49:44.453834936 -0500
+++ b/drivers/hid/ipts/mei.c	2023-01-16 14:12:51.000000000 -0500
@@ -6,104 +6,184 @@
  * Linux driver for Intel Precise Touch & Stylus
  */
 
-#include <linux/completion.h>
-#include <linux/delay.h>
 #include <linux/device.h>
-#include <linux/dma-mapping.h>
+#include <linux/errno.h>
+#include <linux/jiffies.h>
+#include <linux/list.h>
 #include <linux/mei_cl_bus.h>
-#include <linux/mod_devicetable.h>
-#include <linux/module.h>
-#include <linux/mutex.h>
-#include <linux/slab.h>
-#include <linux/stddef.h>
+#include <linux/printk.h>
+#include <linux/rwsem.h>
 #include <linux/types.h>
+#include <linux/wait.h>
 
 #include "context.h"
-#include "control.h"
-#include "receiver.h"
-#include "spec-device.h"
+#include "mei.h"
 
-/*
- * The MEI client ID for IPTS functionality.
- */
-#define IPTS_MEI_UUID                                                                              \
-	UUID_LE(0x3e8d0870, 0x271a, 0x4208, 0x8e, 0xb5, 0x9a, 0xcb, 0x94, 0x02, 0xae, 0x04)
+static void locked_list_add(struct list_head *new, struct list_head *head,
+			    struct mutex *lock)
+{
+	mutex_lock(lock);
+	list_add(new, head);
+	mutex_unlock(lock);
+}
 
-static int ipts_mei_set_dma_mask(struct mei_cl_device *cldev)
+static void locked_list_del(struct list_head *entry, struct mutex *lock)
 {
-	if (!dma_coerce_mask_and_coherent(&cldev->dev, DMA_BIT_MASK(64)))
-		return 0;
+	mutex_lock(lock);
+	list_del(entry);
+	mutex_unlock(lock);
+}
+
+static void ipts_mei_incoming(struct mei_cl_device *cldev)
+{
+	ssize_t ret = 0;
+	struct ipts_mei_message *entry = NULL;
+	struct ipts_context *ipts = NULL;
+
+	if (!cldev) {
+		pr_err("MEI device is NULL!");
+		return;
+	}
+
+	ipts = mei_cldev_get_drvdata(cldev);
+	if (!ipts) {
+		pr_err("IPTS driver context is NULL!");
+		return;
+	}
 
-	return dma_coerce_mask_and_coherent(&cldev->dev, DMA_BIT_MASK(32));
+	entry = devm_kzalloc(ipts->dev, sizeof(*entry), GFP_KERNEL);
+	if (!entry)
+		return;
+
+	INIT_LIST_HEAD(&entry->list);
+
+	do {
+		ret = mei_cldev_recv(cldev, (u8 *)&entry->rsp, sizeof(entry->rsp));
+	} while (ret == -EINTR);
+
+	if (ret < 0) {
+		dev_err(ipts->dev, "Error while reading response: %ld\n", ret);
+		return;
+	}
+
+	if (ret == 0) {
+		dev_err(ipts->dev, "Received empty response\n");
+		return;
+	}
+
+	locked_list_add(&entry->list, &ipts->mei.messages, &ipts->mei.message_lock);
+	wake_up_all(&ipts->mei.message_queue);
 }
 
-static int ipts_mei_probe(struct mei_cl_device *cldev, const struct mei_cl_device_id *id)
+static int ipts_mei_search(struct ipts_mei *mei, enum ipts_command_code code,
+			   struct ipts_response *rsp)
 {
-	int ret;
-	struct ipts_context *ipts;
+	struct ipts_mei_message *entry = NULL;
 
-	ret = ipts_mei_set_dma_mask(cldev);
-	if (ret) {
-		dev_err(&cldev->dev, "Failed to set DMA mask for IPTS: %d\n", ret);
-		return ret;
+	if (!mei)
+		return -EFAULT;
+
+	if (!rsp)
+		return -EFAULT;
+
+	mutex_lock(&mei->message_lock);
+
+	/*
+	 * Iterate over the list of received messages, and check if there is one
+	 * matching the requested command code.
+	 */
+	list_for_each_entry(entry, &mei->messages, list) {
+		if (entry->rsp.cmd == code)
+			break;
 	}
 
-	ret = mei_cldev_enable(cldev);
-	if (ret) {
-		dev_err(&cldev->dev, "Failed to enable MEI device: %d\n", ret);
-		return ret;
+	mutex_unlock(&mei->message_lock);
+
+	/*
+	 * If entry is not the list head, this means that the loop above has been stopped early,
+	 * and that we found a matching element. We drop the message from the list and return it.
+	 */
+	if (!list_entry_is_head(entry, &mei->messages, list)) {
+		locked_list_del(&entry->list, &mei->message_lock);
+
+		*rsp = entry->rsp;
+		devm_kfree(&mei->cldev->dev, entry);
+
+		return 0;
 	}
 
-	ipts = devm_kzalloc(&cldev->dev, sizeof(*ipts), GFP_KERNEL);
-	if (!ipts) {
-		mei_cldev_disable(cldev);
-		return -ENOMEM;
+	return -EAGAIN;
+}
+
+int ipts_mei_recv(struct ipts_mei *mei, enum ipts_command_code code, struct ipts_response *rsp,
+		  u64 timeout)
+{
+	int ret = 0;
+
+	if (!mei)
+		return -EFAULT;
+
+	/*
+	 * A timeout of 0 means check and return immideately.
+	 */
+	if (timeout == 0)
+		return ipts_mei_search(mei, code, rsp);
+
+	/*
+	 * A timeout of less than 0 means to wait forever.
+	 */
+	if (timeout < 0) {
+		wait_event(mei->message_queue, ipts_mei_search(mei, code, rsp) == 0);
+		return 0;
 	}
 
-	ipts->cldev = cldev;
-	ipts->dev = &cldev->dev;
-	ipts->mode = IPTS_MODE_EVENT;
+	ret = wait_event_timeout(mei->message_queue, ipts_mei_search(mei, code, rsp) == 0,
+				 msecs_to_jiffies(timeout));
+
+	if (ret > 0)
+		return 0;
+
+	return -EAGAIN;
+}
+
+int ipts_mei_send(struct ipts_mei *mei, void *data, size_t length)
+{
+	int ret = 0;
+
+	if (!mei)
+		return -EFAULT;
 
-	mutex_init(&ipts->feature_lock);
-	init_completion(&ipts->feature_event);
+	if (!mei->cldev)
+		return -EFAULT;
 
-	mei_cldev_set_drvdata(cldev, ipts);
+	if (!data)
+		return -EFAULT;
 
-	ret = ipts_control_start(ipts);
-	if (ret) {
-		dev_err(&cldev->dev, "Failed to start IPTS: %d\n", ret);
+	do {
+		ret = mei_cldev_send(mei->cldev, (u8 *)data, length);
+	} while (ret == -EINTR);
+
+	if (ret < 0)
 		return ret;
-	}
 
 	return 0;
 }
 
-static void ipts_mei_remove(struct mei_cl_device *cldev)
+int ipts_mei_init(struct ipts_mei *mei, struct mei_cl_device *cldev)
 {
-	int ret;
-	struct ipts_context *ipts = mei_cldev_get_drvdata(cldev);
+	if (!mei)
+		return -EFAULT;
+
+	if (!cldev)
+		return -EFAULT;
 
-	ret = ipts_control_stop(ipts);
-	if (ret)
-		dev_err(&cldev->dev, "Failed to stop IPTS: %d\n", ret);
-
-	mei_cldev_disable(cldev);
-}
-
-static struct mei_cl_device_id ipts_mei_device_id_table[] = {
-	{ .uuid = IPTS_MEI_UUID, .version = MEI_CL_VERSION_ANY },
-	{},
-};
-MODULE_DEVICE_TABLE(mei, ipts_mei_device_id_table);
-
-static struct mei_cl_driver ipts_mei_driver = {
-	.id_table = ipts_mei_device_id_table,
-	.name = "ipts",
-	.probe = ipts_mei_probe,
-	.remove = ipts_mei_remove,
-};
-module_mei_cl_driver(ipts_mei_driver);
-
-MODULE_DESCRIPTION("IPTS touchscreen driver");
-MODULE_AUTHOR("Dorian Stoll <dorian.stoll@tmsp.io>");
-MODULE_LICENSE("GPL");
+	mei->cldev = cldev;
+
+	INIT_LIST_HEAD(&mei->messages);
+	init_waitqueue_head(&mei->message_queue);
+	mutex_init(&mei->message_lock);
+
+	mei_cldev_register_rx_cb(cldev, ipts_mei_incoming);
+
+	return 0;
+}
diff -Npur a/drivers/hid/ipts/mei.h b/drivers/hid/ipts/mei.h
--- a/drivers/hid/ipts/mei.h	1969-12-31 19:00:00.000000000 -0500
+++ b/drivers/hid/ipts/mei.h	2023-01-16 14:12:51.000000000 -0500
@@ -0,0 +1,67 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020-2022 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#ifndef IPTS_MEI_H
+#define IPTS_MEI_H
+
+#include <linux/list.h>
+#include <linux/mei_cl_bus.h>
+#include <linux/rwsem.h>
+#include <linux/types.h>
+#include <linux/wait.h>
+
+#include "spec-device.h"
+
+struct ipts_mei_message {
+	struct list_head list;
+	struct ipts_response rsp;
+};
+
+struct ipts_mei {
+	struct mei_cl_device *cldev;
+
+	struct list_head messages;
+
+	wait_queue_head_t message_queue;
+	struct mutex message_lock;
+};
+
+/*
+ * ipts_mei_recv() - Receive data from a MEI device.
+ * @mei: The IPTS MEI device context.
+ * @code: The IPTS command code to look for.
+ * @rsp: The address that the received data will be copied to.
+ * @timeout: How many milliseconds the function will wait at most.
+ *
+ * A negative timeout means to wait forever.
+ *
+ * Returns: 0 on success, <0 on error, -EAGAIN if no response has been received.
+ */
+int ipts_mei_recv(struct ipts_mei *mei, enum ipts_command_code code, struct ipts_response *rsp,
+		  u64 timeout);
+
+/*
+ * ipts_mei_send() - Send data to a MEI device.
+ * @ipts: The IPTS MEI device context.
+ * @data: The data to send.
+ * @size: The size of the data.
+ *
+ * Returns: 0 on success, <0 on error.
+ */
+int ipts_mei_send(struct ipts_mei *mei, void *data, size_t length);
+
+/*
+ * ipts_mei_init() - Initialize the MEI device context.
+ * @mei: The MEI device context to initialize.
+ * @cldev: The MEI device the context will be bound to.
+ *
+ * Returns: 0 on success, <0 on error.
+ */
+int ipts_mei_init(struct ipts_mei *mei, struct mei_cl_device *cldev);
+
+#endif /* IPTS_MEI_H */
diff -Npur a/drivers/hid/ipts/receiver.c b/drivers/hid/ipts/receiver.c
--- a/drivers/hid/ipts/receiver.c	2023-01-15 22:49:44.453834936 -0500
+++ b/drivers/hid/ipts/receiver.c	2023-01-16 14:12:51.000000000 -0500
@@ -7,6 +7,7 @@
  */
 
 #include <linux/delay.h>
+#include <linux/err.h>
 #include <linux/kthread.h>
 #include <linux/time64.h>
 #include <linux/timekeeping.h>
@@ -40,15 +41,15 @@ static void ipts_receiver_backoff(time64
 	 * n seconds, sleep longer to avoid wasting CPU cycles.
 	 */
 	if (last + n > ktime_get_seconds())
-		msleep(12);
+		msleep(12);
 	else
-		msleep(130);
+		msleep(130);
 }
 
 static int ipts_receiver_event_loop(void *data)
 {
-	int ret;
-	u32 buffer;
+	int ret = 0;
+	u32 buffer = 0;
 
 	struct ipts_context *ipts = data;
 	time64_t last = ktime_get_seconds();
@@ -99,13 +100,21 @@ static int ipts_receiver_event_loop(void
 	ret = ipts_control_wait_data(ipts, true);
 	if (ret) {
 		dev_err(ipts->dev, "Failed to wait for data: %d\n", ret);
-		return ret;
+
+		if (ret != -EAGAIN)
+			return ret;
+		else
+			return 0;
 	}
 
 	ret = ipts_control_wait_flush(ipts);
 	if (ret) {
 		dev_err(ipts->dev, "Failed to wait for flush: %d\n", ret);
-		return ret;
+
+		if (ret != -EAGAIN)
+			return ret;
+		else
+			return 0;
 	}
 
 	return 0;
@@ -113,8 +122,8 @@ static int ipts_receiver_event_loop(void
 
 static int ipts_receiver_doorbell_loop(void *data)
 {
-	int ret;
-	u32 buffer;
+	int ret = 0;
+	u32 buffer = 0;
 
 	u32 doorbell = 0;
 	u32 lastdb = 0;
@@ -167,42 +176,65 @@ static int ipts_receiver_doorbell_loop(v
 	ret = ipts_control_wait_data(ipts, true);
 	if (ret) {
 		dev_err(ipts->dev, "Failed to wait for data: %d\n", ret);
-		return ret;
+
+		if (ret != -EAGAIN)
+			return ret;
+		else
+			return 0;
 	}
 
 	ret = ipts_control_wait_flush(ipts);
 	if (ret) {
 		dev_err(ipts->dev, "Failed to wait for flush: %d\n", ret);
-		return ret;
+
+		if (ret != -EAGAIN)
+			return ret;
+		else
+			return 0;
 	}
 
 	return 0;
 }
 
-void ipts_receiver_start(struct ipts_context *ipts)
+int ipts_receiver_start(struct ipts_context *ipts)
 {
 	if (!ipts)
-		return;
+		return -EFAULT;
 
 	if (ipts->mode == IPTS_MODE_EVENT)
-		ipts->event_loop = kthread_run(ipts_receiver_event_loop, ipts, "ipts_event");
+		ipts->receiver_loop = kthread_run(ipts_receiver_event_loop, ipts, "ipts_event");
+	else if (ipts->mode == IPTS_MODE_DOORBELL)
+		ipts->receiver_loop = kthread_run(ipts_receiver_doorbell_loop, ipts, "ipts_db");
+	else
+		return -EINVAL;
+
+	if (IS_ERR(ipts->receiver_loop)) {
+		int err = PTR_ERR(ipts->receiver_loop);
 
-	if (ipts->mode == IPTS_MODE_DOORBELL)
-		ipts->doorbell_loop = kthread_run(ipts_receiver_doorbell_loop, ipts, "ipts_db");
+		dev_err(ipts->dev, "Failed to start receiver loop: %d\n", err);
+		return err;
+	}
+
+	return 0;
 }
 
-void ipts_receiver_stop(struct ipts_context *ipts)
+int ipts_receiver_stop(struct ipts_context *ipts)
 {
+	int ret = 0;
+
 	if (!ipts)
-		return;
+		return -EFAULT;
 
-	if (ipts->event_loop) {
-		kthread_stop(ipts->event_loop);
-		ipts->event_loop = NULL;
-	}
+	if (!ipts->receiver_loop)
+		return 0;
 
-	if (ipts->doorbell_loop) {
-		kthread_stop(ipts->doorbell_loop);
-		ipts->doorbell_loop = NULL;
+	ret = kthread_stop(ipts->receiver_loop);
+	ipts->receiver_loop = NULL;
+
+	if (ret) {
+		dev_err(ipts->dev, "Failed to stop receiver loop: %d\n", ret);
+		return ret;
 	}
+
+	return 0;
 }
diff -Npur a/drivers/hid/ipts/receiver.h b/drivers/hid/ipts/receiver.h
--- a/drivers/hid/ipts/receiver.h	2023-01-15 22:49:44.453834936 -0500
+++ b/drivers/hid/ipts/receiver.h	2023-01-16 14:12:51.000000000 -0500
@@ -11,7 +11,7 @@
 
 #include "context.h"
 
-void ipts_receiver_start(struct ipts_context *ipts);
-void ipts_receiver_stop(struct ipts_context *ipts);
+int ipts_receiver_start(struct ipts_context *ipts);
+int ipts_receiver_stop(struct ipts_context *ipts);
 
 #endif /* IPTS_RECEIVER_H */
diff -Npur a/drivers/hid/ipts/resources.c b/drivers/hid/ipts/resources.c
--- a/drivers/hid/ipts/resources.c	2023-01-15 22:49:44.453834936 -0500
+++ b/drivers/hid/ipts/resources.c	2023-01-16 14:12:51.000000000 -0500
@@ -33,7 +33,7 @@ static int ipts_resources_alloc_buffer(s
 
 static void ipts_resources_free_buffer(struct ipts_buffer *buffer)
 {
-	if (!buffer || !buffer->address)
+	if (!buffer->address)
 		return;
 
 	dma_free_coherent(buffer->device, buffer->size, buffer->address, buffer->dma_address);
@@ -47,7 +47,7 @@ static void ipts_resources_free_buffer(s
 
 int ipts_resources_init(struct ipts_resources *res, struct device *dev, size_t ds, size_t fs)
 {
-	int ret;
+	int ret = 0;
 
 	if (!res)
 		return -EFAULT;
@@ -88,10 +88,10 @@ err:
 	return ret;
 }
 
-void ipts_resources_free(struct ipts_resources *res)
+int ipts_resources_free(struct ipts_resources *res)
 {
 	if (!res)
-		return;
+		return -EFAULT;
 
 	for (int i = 0; i < IPTS_BUFFERS; i++)
 		ipts_resources_free_buffer(&res->data[i]);
@@ -103,4 +103,6 @@ void ipts_resources_free(struct ipts_res
 	ipts_resources_free_buffer(&res->workqueue);
 	ipts_resources_free_buffer(&res->hid2me);
 	ipts_resources_free_buffer(&res->descriptor);
+
+	return 0;
 }
diff -Npur a/drivers/hid/ipts/resources.h b/drivers/hid/ipts/resources.h
--- a/drivers/hid/ipts/resources.h	2023-01-15 22:49:44.453834936 -0500
+++ b/drivers/hid/ipts/resources.h	2023-01-16 14:12:51.000000000 -0500
@@ -34,6 +34,6 @@ struct ipts_resources {
 };
 
 int ipts_resources_init(struct ipts_resources *res, struct device *dev, size_t ds, size_t fs);
-void ipts_resources_free(struct ipts_resources *res);
+int ipts_resources_free(struct ipts_resources *res);
 
 #endif /* IPTS_RESOURCES_H */

diff --git a/drivers/hid/ipts/Makefile b/drivers/hid/ipts/Makefile
index 3e045d7..0fe655b 100644
--- a/drivers/hid/ipts/Makefile
+++ b/drivers/hid/ipts/Makefile
@@ -11,3 +11,4 @@ ipts-objs += main.o
 ipts-objs += mei.o
 ipts-objs += receiver.o
 ipts-objs += resources.o
+ipts-objs += thread.o
diff --git a/drivers/hid/ipts/context.h b/drivers/hid/ipts/context.h
index c60d158..a005657 100644
--- a/drivers/hid/ipts/context.h
+++ b/drivers/hid/ipts/context.h
@@ -20,6 +20,7 @@
 #include "mei.h"
 #include "resources.h"
 #include "spec-device.h"
+#include "thread.h"
 
 struct ipts_context {
 	struct device *dev;
@@ -41,7 +42,7 @@ struct ipts_context {
 	struct ipts_device_info info;
 	struct ipts_resources resources;
 
-	struct task_struct *receiver_loop;
+	struct ipts_thread receiver_loop;
 };
 
 #endif /* IPTS_CONTEXT_H */
diff --git a/drivers/hid/ipts/receiver.c b/drivers/hid/ipts/receiver.c
index 86410be..95c5639 100644
--- a/drivers/hid/ipts/receiver.c
+++ b/drivers/hid/ipts/receiver.c
@@ -19,6 +19,7 @@
 #include "hid.h"
 #include "resources.h"
 #include "spec-device.h"
+#include "thread.h"
 
 static void ipts_receiver_next_doorbell(struct ipts_context *ipts)
 {
@@ -46,20 +47,25 @@ static void ipts_receiver_backoff(time64_t last, u32 n)
 		msleep(200);
 }
 
-static int ipts_receiver_event_loop(void *data)
+static int ipts_receiver_event_loop(struct ipts_thread *thread)
 {
 	int ret = 0;
 	u32 buffer = 0;
 
-	struct ipts_context *ipts = data;
+	struct ipts_context *ipts = NULL;
 	time64_t last = ktime_get_seconds();
 
+	if (!thread)
+		return -EFAULT;
+
+	ipts = thread->data;
+
 	if (!ipts)
 		return -EFAULT;
 
 	dev_info(ipts->dev, "IPTS running in event mode\n");
 
-	while (!kthread_should_stop()) {
+	while (!ipts_thread_should_stop(thread)) {
 		for (int i = 0; i < IPTS_BUFFERS; i++) {
 			ret = ipts_control_wait_data(ipts, false);
 			if (ret == -EAGAIN)
@@ -120,7 +126,7 @@ static int ipts_receiver_event_loop(void *data)
 	return 0;
 }
 
-static int ipts_receiver_doorbell_loop(void *data)
+static int ipts_receiver_doorbell_loop(struct ipts_thread *thread)
 {
 	int ret = 0;
 	u32 buffer = 0;
@@ -128,16 +134,21 @@ static int ipts_receiver_doorbell_loop(void *data)
 	u32 doorbell = 0;
 	u32 lastdb = 0;
 
-	struct ipts_context *ipts = data;
+	struct ipts_context *ipts = NULL;
 	time64_t last = ktime_get_seconds();
 
+	if (!thread)
+		return -EFAULT;
+
+	ipts = thread->data;
+
 	if (!ipts)
 		return -EFAULT;
 
 	dev_info(ipts->dev, "IPTS running in doorbell mode\n");
 
 	while (true) {
-		if (kthread_should_stop()) {
+		if (ipts_thread_should_stop(thread)) {
 			ret = ipts_control_request_flush(ipts);
 			if (ret) {
 				dev_err(ipts->dev, "Failed to request flush: %d\n", ret);
@@ -167,7 +178,7 @@ static int ipts_receiver_doorbell_loop(void *data)
 			lastdb++;
 		}
 
-		if (kthread_should_stop())
+		if (ipts_thread_should_stop(thread))
 			break;
 
 		ipts_receiver_backoff(last, 5);
@@ -198,21 +209,24 @@ static int ipts_receiver_doorbell_loop(void *data)
 
 int ipts_receiver_start(struct ipts_context *ipts)
 {
+	int ret = 0;
+
 	if (!ipts)
 		return -EFAULT;
 
-	if (ipts->mode == IPTS_MODE_EVENT)
-		ipts->receiver_loop = kthread_run(ipts_receiver_event_loop, ipts, "ipts_event");
-	else if (ipts->mode == IPTS_MODE_DOORBELL)
-		ipts->receiver_loop = kthread_run(ipts_receiver_doorbell_loop, ipts, "ipts_db");
-	else
-		return -EINVAL;
-
-	if (IS_ERR(ipts->receiver_loop)) {
-		int err = PTR_ERR(ipts->receiver_loop);
+	if (ipts->mode == IPTS_MODE_EVENT) {
+		ret = ipts_thread_start(&ipts->receiver_loop, ipts_receiver_event_loop, ipts,
+					"ipts_event");
+	} else if (ipts->mode == IPTS_MODE_DOORBELL) {
+		ret = ipts_thread_start(&ipts->receiver_loop, ipts_receiver_doorbell_loop, ipts,
+					"ipts_doorbell");
+	} else {
+		ret = -EINVAL;
+	}
 
-		dev_err(ipts->dev, "Failed to start receiver loop: %d\n", err);
-		return err;
+	if (ret) {
+		dev_err(ipts->dev, "Failed to start receiver loop: %d\n", ret);
+		return ret;
 	}
 
 	return 0;
@@ -225,12 +239,7 @@ int ipts_receiver_stop(struct ipts_context *ipts)
 	if (!ipts)
 		return -EFAULT;
 
-	if (!ipts->receiver_loop)
-		return 0;
-
-	ret = kthread_stop(ipts->receiver_loop);
-	ipts->receiver_loop = NULL;
-
+	ret = ipts_thread_stop(&ipts->receiver_loop);
 	if (ret) {
 		dev_err(ipts->dev, "Failed to stop receiver loop: %d\n", ret);
 		return ret;
diff --git a/drivers/hid/ipts/thread.c b/drivers/hid/ipts/thread.c
new file mode 100644
index 0000000..5726031
--- /dev/null
+++ b/drivers/hid/ipts/thread.c
@@ -0,0 +1,89 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020-2022 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#include <linux/completion.h>
+#include <linux/err.h>
+#include <linux/kthread.h>
+#include <linux/mutex.h>
+
+#include "thread.h"
+
+bool ipts_thread_should_stop(struct ipts_thread *thread)
+{
+	bool ret = false;
+
+	if (!thread)
+		return false;
+
+	mutex_lock(&thread->lock);
+	ret = thread->should_stop;
+	mutex_unlock(&thread->lock);
+
+	return ret;
+}
+
+static int ipts_thread_runner(void *data)
+{
+	int ret = 0;
+	struct ipts_thread *thread = data;
+
+	if (!thread)
+		return -EFAULT;
+
+	if (!thread->threadfn)
+		return -EFAULT;
+
+	ret = thread->threadfn(thread);
+	complete_all(&thread->done);
+
+	return ret;
+}
+
+int ipts_thread_start(struct ipts_thread *thread, int (*threadfn)(struct ipts_thread *thread),
+		      void *data, const char *name)
+{
+	if (!thread)
+		return -EFAULT;
+
+	if (!threadfn)
+		return -EFAULT;
+
+	mutex_init(&thread->lock);
+	init_completion(&thread->done);
+
+	thread->data = data;
+	thread->should_stop = false;
+	thread->threadfn = threadfn;
+
+	thread->thread = kthread_run(ipts_thread_runner, thread, name);
+	return PTR_ERR_OR_ZERO(thread->thread);
+}
+
+int ipts_thread_stop(struct ipts_thread *thread)
+{
+	int ret = 0;
+
+	if (!thread)
+		return -EFAULT;
+
+	if (!thread->thread)
+		return 0;
+
+	mutex_lock(&thread->lock);
+	thread->should_stop = true;
+	mutex_unlock(&thread->lock);
+
+	wait_for_completion(&thread->done);
+	ret = kthread_stop(thread->thread);
+
+	thread->thread = NULL;
+	thread->data = NULL;
+	thread->threadfn = NULL;
+
+	return ret;
+}
diff --git a/drivers/hid/ipts/thread.h b/drivers/hid/ipts/thread.h
new file mode 100644
index 0000000..b51f104
--- /dev/null
+++ b/drivers/hid/ipts/thread.h
@@ -0,0 +1,62 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020-2022 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#ifndef IPTS_THREAD_H
+#define IPTS_THREAD_H
+
+#include <linux/completion.h>
+#include <linux/mutex.h>
+#include <linux/sched.h>
+
+/*
+ * This wrapper over kthread is neccessary, because calling kthread_stop makes it impossible
+ * to issue MEI commands from that thread while it shuts itself down. By using a custom
+ * boolean variable and a completion object, we can call kthread_stop only when the thread
+ * already finished all of its work and has returned.
+*/
+struct ipts_thread {
+	struct task_struct *thread;
+
+	bool should_stop;
+
+	struct mutex lock;
+	struct completion done;
+
+	void *data;
+	int (*threadfn)(struct ipts_thread *thread);
+};
+
+/*
+ * ipts_thread_should_stop() - Returns true if the thread is asked to terminate.
+ * @thread: The current thread.
+ *
+ * Returns: true if the thread should stop, false if not.
+ */
+bool ipts_thread_should_stop(struct ipts_thread *thread);
+
+/*
+ * ipts_thread_start() - Starts an IPTS thread.
+ * @thread: The thread to initialize and start.
+ * @threadfn: The function to execute.
+ * @data: An argument that will be passed to threadfn.
+ * @name: The name of the new thread.
+ *
+ * Returns: 0 on success, <0 on error.
+ */
+int ipts_thread_start(struct ipts_thread *thread, int (*threadfn)(struct ipts_thread *thread),
+		      void *data, const char name[]);
+
+/*
+ * ipts_thread_stop() - Asks the thread to terminate and waits until it has finished.
+ * @thread: The thread that should stop.
+ *
+ * Returns: The return value of the thread function.
+ */
+int ipts_thread_stop(struct ipts_thread *thread);
+
+#endif /* IPTS_THREAD_H */

