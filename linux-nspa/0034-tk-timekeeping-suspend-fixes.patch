From 246e82eacc04184b8b644e5c114af8c15b993f9f Mon Sep 17 00:00:00 2001
From: Sultan Alsawaf <sultan@kerneltoast.com>
Date: Sun, 17 Apr 2022 10:53:19 -0700
Subject: [PATCH] Revert "cpuidle: don't disable cpuidle when entering suspend"

This reverts commit 0b3cc77678b9500f240c9a550f74302d0f5760da.

The workflow of s2idle requires the cpuidle_resume() in dpm_noirq_end(),
otherwise cpuidle never gets re-enabled after exiting s2idle.

 --modified/rebased to apply over 5.18-nspa

Signed-off-by: Sultan Alsawaf <sultan@kerneltoast.com>
---
 drivers/base/power/main.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/drivers/base/power/main.c b/drivers/base/power/main.c
index 1b9d660bc4d1..e8676b395550 100644
--- a/drivers/base/power/main.c
+++ b/drivers/base/power/main.c
@@ -32,6 +32,7 @@
 #include <linux/suspend.h>
 #include <trace/events/power.h>
 #include <linux/cpufreq.h>
+#include <linux/cpuidle.h>
 #include <linux/devfreq.h>
 #include <linux/timer.h>
 
@@ -748,6 +749,7 @@ void dpm_resume_noirq(pm_message_t state
 
 	resume_device_irqs();
 	device_wakeup_disarm_wake_irqs();
+	cpuidle_resume();
 }
 
 /**
@@ -1350,6 +1352,7 @@ int dpm_suspend_noirq(pm_message_t state
 {
 	int ret;
 
+	cpuidle_pause();
 	device_wakeup_arm_wake_irqs();
 	suspend_device_irqs();
 
From 333ea93ca815491487007f1d712a574fe4f9d4c3 Mon Sep 17 00:00:00 2001
From: Sultan Alsawaf <sultan@kerneltoast.com>
Date: Sat, 30 Apr 2022 11:47:30 -0700
Subject: [PATCH] timekeeping: Keep the tick alive when CPUs cycle out of
 s2idle

When some CPUs cycle out of s2idle due to non-wakeup IRQs, it's possible
for them to run while the CPU responsible for jiffies updates remains idle.
This can delay the execution of timers indefinitely until the CPU managing
the jiffies updates finally wakes up, by which point everything could be
dead if enough time passes.

Fix it by handing off timekeeping duties when the timekeeping CPU enters
s2idle and freezes its tick. When all CPUs are in s2idle, the first one to
wake up for any reason (either from a wakeup IRQ or non-wakeup IRQ) will
assume responsibility for the timekeeping tick.

 --modified/rebased to apply over 5.18-nspa

Signed-off-by: Sultan Alsawaf <sultan@kerneltoast.com>
---
 kernel/time/tick-common.c | 21 ++++++++++++++++-----
 1 file changed, 16 insertions(+), 5 deletions(-)

diff --git a/kernel/time/tick-common.c b/kernel/time/tick-common.c
index b9c077a160ed..d228058405b2 100644
--- a/kernel/time/tick-common.c
+++ b/kernel/time/tick-common.c
@@ -510,7 +510,7 @@ void tick_resume(void)
 
 #ifdef CONFIG_SUSPEND
 static DEFINE_RAW_SPINLOCK(tick_freeze_lock);
-static unsigned int tick_freeze_depth;
+static unsigned long tick_frozen_mask;
 
 /**
  * tick_freeze - Suspend the local tick and (possibly) timekeeping.
@@ -523,10 +523,17 @@ static unsigned int tick_freeze_depth;
  */
 void tick_freeze(void)
 {
+	int cpu = smp_processor_id();
+
 	raw_spin_lock(&tick_freeze_lock);
 
-	tick_freeze_depth++;
-	if (tick_freeze_depth == num_online_cpus()) {
+	tick_frozen_mask |= BIT(cpu);
+	if (tick_do_timer_cpu == cpu) {
+		cpu = ffz(tick_frozen_mask);
+		tick_do_timer_cpu = (cpu < nr_cpu_ids) ? cpu :
+			TICK_DO_TIMER_NONE;
+	}
+	if (tick_frozen_mask == *cpumask_bits(cpu_online_mask)) {
 		trace_suspend_resume(TPS("timekeeping_freeze"),
 				     smp_processor_id(), true);
 		system_state = SYSTEM_SUSPEND;
@@ -550,9 +557,11 @@ void tick_freeze(void)
  */
 void tick_unfreeze(void)
 {
+	int cpu = smp_processor_id();
+
 	raw_spin_lock(&tick_freeze_lock);
 
-	if (tick_freeze_depth == num_online_cpus()) {
+	if (tick_frozen_mask == *cpumask_bits(cpu_online_mask)) {
 		timekeeping_resume();
 		sched_clock_resume();
 		system_state = SYSTEM_RUNNING;
@@ -562,8 +571,10 @@ void tick_unfreeze(void)
 		touch_softlockup_watchdog();
 		tick_resume_local();
 	}
+	if (tick_do_timer_cpu == TICK_DO_TIMER_NONE)
+		tick_do_timer_cpu = cpu;
 
-	tick_freeze_depth--;
+	tick_frozen_mask &= ~BIT(cpu);
 
 	raw_spin_unlock(&tick_freeze_lock);
 }
